<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/simon-blog.github.io/2020/08/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>python元类和装饰器</title>
    <url>/simon-blog.github.io/2020/08/08/python%E5%85%83%E7%B1%BB%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h2><p>动态添加函数功能，相当于在原函数上套了一层皮，动态添加新的职责。比如Django，flask里的@session现在终于是弄明白那一块用户身份验证的原理了。（在原来的view函数上使用装饰者模式，如果http请求里包含了session的ID就允许render，从而实现一些页面对于用户的隐藏）</p>
<a id="more"></a>
<p>相关的身份验证代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(f)        # 这里的@开头的部分就是一个装饰器，虽然他不是重点，只是用来确保原函数属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure>
<p>可能这样看并不明显，那么接下来两个例子就很好的说明了他的具体用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>a_new_decorator 这个函数以另一个函数为变量，a_function_requiring_decoration在使用装饰函数包裹他之后，他的输出就额外多出了两行。但是这并不是decorator的典型写法，下面才是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>使用@开始一个装饰器，非常的优雅。同时装饰器并不是只能这么笨重的使用，他也是函数，他也是对象。那么他就可以附加额外的参数，甚至你可以定义一个装饰器类。当然这里就不展开细讲了。详细可以左转</p>
<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python装饰器函数</a> </p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>可以创建类的类，听起来是不是很像工厂模式？虽然很像，但他可不只单单可以创建类那么简单，甚至可以修改已经创建好的类的属性。</p>
<p>正常的创建类的方式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = type(<span class="string">&#x27;Myclass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>使用元类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMeta</span>(<span class="params">type</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用元类实现给类添加属性 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, attrs</span>):</span></span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(mcs, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>(<span class="params">list, metaclass=ListMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">l = MyList()</span><br><span class="line">l.add(<span class="number">1</span>)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>
<p>你可能会奇怪，怎么写的这么别扭，还用了lamda函数，就往原来的类里面加了个add方法，那我用装饰器不就好了。U1S1,QS. 但是，元类绝对不是这么鸡肋的存在。我所了解的，Django，flask这些框架使用的ORM就是基于元类，对于model类的动态控制，来实现mysql语句的更新和管理使用到的数据。同时，元类还可以用于创建python里的单列模式。（但python所有东西都是对象，真的有必要单列吗）</p>
<h2 id="类的new和init"><a href="#类的new和init" class="headerlink" title="类的new和init"></a>类的<strong>new</strong>和<strong>init</strong></h2><p>惊了，markdown打不出来<strong>new</strong>方法吗，会变成加粗字体。嘛，反正你们也知道我在说什么吧。</p>
<p>一般在python里<strong>new</strong>方法创建实例，<strong>init</strong>负责初始化一个实例。<strong>new</strong>方法返回创建的对象，而<strong>init</strong>方法禁止返回值(必须返回None)。有一个简单的原则来判断什么使用使用<strong>init</strong>和<strong>new</strong>：</p>
<ul>
<li>如果需要修改类的属性，使用元类的<strong>new</strong>方法</li>
<li>如果只是做一些类属性检查的工作，使用元类的<strong>init</strong>方法</li>
<li>如果 new 方法不返回对象， 则不会调用 init 函数</li>
</ul>
<p>我能想到的这部分知识就先整理成这样吧，如果想起来还会加的。最后放一下参考的文章</p>
<p><a href="https://blog.csdn.net/kisslotus/article/details/83793781#4___new____init___132">Python 高级编程之元类和装饰器</a> </p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>常见网络攻击</title>
    <url>/simon-blog.github.io/2020/08/08/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前总结了网络的一些知识点，大概可以用网络的4层协议模型概括。虽然前博客的数据没了，但我会从新写一遍。今天就先来看一下之前没提到的网络安全这一块吧，也算是给自己查漏补缺了。<br><a id="more"></a></p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><hr>
<p>这个相信大家肯定都有所耳闻，以前我天真的以为就是在url的后面加上<code>or 1=1</code>显然并不是这样。在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。比如你输入用户名密码登录时，你将请求修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ‘lianggzone’ <span class="keyword">and</span> <span class="keyword">password</span> = ‘’ <span class="keyword">or</span> ‘<span class="number">1</span>’=‘<span class="number">1</span>’</span><br></pre></td></tr></table></figure>
<p>甚至，以前的校园网，不严谨的，设置密码时本身加上drop table这种，都属于SQL注入。所以他的原理很简单，让本应该只有一句SQL的语句，通过狗尾续貂的方式，再加上一句，使得SQL傻乎乎的去执行了第二句恶心代码。</p>
<p>那么我们防御的目标也就很明确了</p>
<ul>
<li>客户端<ul>
<li>有效性检验。</li>
<li>限制字符串输入的长度。 </li>
</ul>
</li>
<li>服务端<ul>
<li>不用拼接SQL字符串。</li>
<li>使用预编译的PrepareStatement。</li>
<li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li>
</ul>
</li>
</ul>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><hr>
<p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。既然我可以在SQL语句上搞猫腻，那我下次在使用评论功能时，在里面写脚本呢？没错，这就是xss攻击了。听起来很蠢，但如果不佳防范他可是能把你内裤是什么颜色都扒个清楚。之后会提到，他和scrf一起攻击，拿到你的cookie信息后有多危险。</p>
<p>但是，他毕竟是显式的需要大摇大摆的写在http请求里的，要避免也并不复杂</p>
<ul>
<li><p>前端，服务端，同时需要字符串输入的长度限制。</p>
</li>
<li><p>前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。</p>
</li>
<li><p>防 XSS 的核心是必须对输入的数据做过滤处理。</p>
</li>
</ul>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><hr>
<p>重头戏，django自带避免csrf的中间件。跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。现在网站大抵都会提醒用户是否使用cookie就是因为害怕这个了。http在设计的时候本就是无状态的，既然是无状态那每次是否都需要做身份验证呢？如果把身份信息放置在一个地方，每次提交请求时直接从那里放进去，不就省了自己输入的麻烦？这也就是coockie的思想。</p>
<p>设想一下，下面的情况：</p>
<ol>
<li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p>
</li>
<li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p>
</li>
<li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p>
</li>
<li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p>
</li>
<li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
</li>
</ol>
<p>上面的这个例子，有几个点需要注意一下。首先csrf攻击并没有拿到你的coockie数据，只是利用了你现在还在登录的这个状态。第二他发送的恶意请求如果不加上反制措施是完全正常的。第三，但是他的确是从B网站而不是A网站发出去的。</p>
<p>针对上述特征，我们似乎可以对症下药了。</p>
<ul>
<li><p>尽量不要使用get去更新重要信息。get是在URL上明文传输的，而且对于穿过去的get请求的验证方式也没有post来的灵活。</p>
</li>
<li><p>送请求时，只有coockie里的信息是不够的。csrf最巧妙的地方就是他是一种愿者上钩的欺骗方式，一切的信息都是你coockie提供的，我只不过是提交了个请求而已。但是如果我们给提交请求额外设条件的话，csrf只能利用coockie，这样他伪造的请求就会因为条件不够而失败。比如：</p>
</li>
<li><p>在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。开始的时候我也是很奇怪，为什么加了一个token就行了。正常自己使用coockie时候也没看需要进行什么额外步骤啊。这是因为，除了cookie中的CSRF-Token外，请求体(POST)或者请求参数(GET)中也要有一个CSRF-Token，两者一样才是有效的。可是你csrf获取不到这个coockie里的token值啊，所以你伪造的请求里一定没有正确的token。（coockie里的token最好是httponly属性）</p>
</li>
<li><p>这个token不一定只可以放在请求里哦，还可以在HTTP头中定义属性验证。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token  值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest  请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
<li><p>还有验证 HTTP Referer 字段的方法，http refer可以鉴别请求的来源地址，如果出自非本站，那很可能就是伪造的请求了。</p>
</li>
</ul>
<h3 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h3><hr>
<p>dos是一台电脑，ddos是多台电脑。因为我们知道http是应用层协议，建立在传输层tcp协议的基础上。那tcp连接要建立的话需要三次握手啊，如果你请求却又不进行第三次握手，相当于放服务器鸽子，服务器负载空增加，甚至严重就宕机了。</p>
<p>说实话这个目前也没什么好办法，毕竟也是合理的游戏规则，要解决就多花钱吧。</p>
<ul>
<li>同时打开SYN半链接的数目</li>
<li>SYN半链接的Time out 时间</li>
<li>不必要的服务</li>
</ul>
<p>最后可能还有一些其他的，比如dns劫持，dns投毒，apr劫持啥的，这里就不细细讨论了啊，为啥呢？因为我想睡觉了。下次一定，下次一定。</p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（一）</title>
    <url>/simon-blog.github.io/2020/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="频率统计和贝叶斯统计"><a href="#频率统计和贝叶斯统计" class="headerlink" title="频率统计和贝叶斯统计"></a>频率统计和贝叶斯统计</h2><p>题外话，果然不管是西澳大学还是墨尔本大学的lecture都是一样的垃圾。始终不能理解为什么有人能听lecture听的津津有味。lecture和最后要做的毫无关系也算是澳洲大学的传统技艺了。</p>
<a id="more"></a>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><hr>
<p>在频率派估计的观点下，真实参数集<em>θ</em>是固定的但未知，我们使用作为数据集函数的随机变量<em>θ</em>作为点估计。频率派统计基于<em>θ</em>作所有的预测。</p>
<p>贝叶斯使用概率来反映知识状态的确定程度。数据集是直接能够观测到因而不是随机的。贝叶斯派认为真实<em>θ</em>是未知的或不确定的，因此以一个随机变量来表示。</p>
<h4 id="总体信息、样本信息和先验信息。"><a href="#总体信息、样本信息和先验信息。" class="headerlink" title="总体信息、样本信息和先验信息。"></a>总体信息、样本信息和先验信息。</h4><p>听起来一脸懵逼，首先理解三个概念：</p>
<p>数理统计学的任务是通过样本推断总体。把样本视为随机变量时，它有概率分布，称为总体分布。如果我们已经知道了总体的概率分布，那我们得到的这种信息就叫做总体信息。（比如投一次硬币是0-1分布）</p>
<p>另一种信息是样本信息，就是从总体中抽取的样本所提供的信息。我们希望通过观察样本的分布，从而对总体的分布或对总体的某些数字特征作出统计推断。（你实际投了几次，实际情况得出的概率）</p>
<p>第三种信息是先验信息（Prior Information），就是在抽样之前，根据经验和历史资料，得到的有关统计推断问题中未知参数的信息。（你投之前就知道硬币就两个面）</p>
<p>基于总体信息和样本信息进行统计推断的理论和方法，称为经典（古典）统计学，它的基本观点是：把样本看成是来自于有一定概率分布的总体，所研究的对象是这个总体而不局限于数据本身。（遇到问题不要怕，我先套个公式先，一定存在一个公式，能完美解释这个情况）</p>
<p>而基于总体信息、样本信息和先验信息进行统计推断的方法和理论，则称为贝叶斯统计学，它与经典统计学的主要区别在于是否利用先验信息。（老兄啊，这硬币反面有磨损的，怎么投都不会是概率0.5的）</p>
<p>在使用样本上也存在差别，贝叶斯统计学重视已出现的样本，对尚未出现的样本不予考虑。所以贝叶斯学派非常重视先验信息的收集、挖掘和加工，使之形成先验分布而参与到统计推断中，以提升统计推断的效果。（就是先入为主，解释了当前现象就行）</p>
<h4 id="主观立场"><a href="#主观立场" class="headerlink" title="主观立场"></a>主观立场</h4><p>主观概率以及先验分布的确定。贝叶斯学派提出了主观概率，把主观概率理解为主体对事件发生的概率的相信程度，即不同的人对同一事件的概率可以得到不同的结果。（他测得是这个模型到底有多可靠）</p>
<p>而频率学派认为一个事件的概率要由大量重复试验下的频率来解释，不应该因人而异，必须具有客观性，而先验分布是主观随意的产物，不可以接受。（通过大量规律，寻找客观存在只是还没被发现的规律）</p>
<p>涉及“频率解释”本身。许多事件是一次性的，在严格或大致相同条件下让这一个事件重复出现是不可能的。（分手了就给我爬开，这辈子都不会有下次一定了）</p>
<p>事前规定精度和可靠度不合理。频率学派基于概率的频率解释，其方法（点估计、区间估计和假设检验）的精度和可靠度，是在事前（抽样前）就定下的，称为“事前精度”和“事前可靠度”。而贝叶斯学派认为统计推断的精度和可靠度，应该与实际的样本值有关，应当采用“事后精度”和“事后可靠度”。</p>
<p>说白了，贝叶斯就比较粗暴，他基于一些事先的评判来做出概率的模型，然后检测这个模型的可靠程度。而old school的频率论就死守着概率推导的严谨性，就好象在和你说茴字有四种写法，在真的确定一个分布前，他做的一切都是0,甚至有的事情情况过于复杂，传统的推导是很难找到其中规律的。贝叶斯选择了像现实妥协。（我个人更喜欢贝叶斯的想法，在我看来频率论就像是连merge sort都写不出来的人在指责你A星算法选的启发式不够好一样）</p>
<h4 id="从对未知参数的认识上来理解"><a href="#从对未知参数的认识上来理解" class="headerlink" title="从对未知参数的认识上来理解"></a>从对未知参数的认识上来理解</h4><p>频率学派把未知参数θ看成一个未知的固定量，仅把样本看做随机变量，而贝叶斯学派把未知参数也看做是随机变量。终于绕回来了，现在在看这句话是不是又有了新的想法。</p>
<h3 id="先验分布、后验分布和共轭分布"><a href="#先验分布、后验分布和共轭分布" class="headerlink" title="先验分布、后验分布和共轭分布"></a>先验分布、后验分布和共轭分布</h3><hr>
<p>贝叶斯统计学与经典统计学的不同之处在于，贝叶斯统计学在统计推断时除了利用抽样信息外，还利用参数的先验信息。先验分布的确定有很大的主观性和随意性，当先验分布完全未知或部分未知时，如果人为给定的先验分布与实际情形偏离较大，那么贝叶斯解的性质就比较差。</p>
<h4 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a><strong>先验分布</strong></h4><p>参数空间Θ上的任一概率分布都称为先验分布（Prior Distribution）。</p>
<p>用π(θ)来表示随机变量θ的概率函数（当θ为连续型随机变量时，π(θ)表示θ的密度函数；当θ为离散型随机变量时，π(θi)表示概率p(θ=θi)，i=1,2,…,n）。</p>
<p>先验分布π(θ)是在抽样样本X之前对参数θ可能取值的认识，在获取样本之后，由于样本X中也包含了θ的信息，故人们对θ的认识发生了变化，于是对θ的取值进行调整，就得到了参数θ的后验分布π(θ|x)。</p>
<p>先验分布的两种重要类型是<strong>无信息先验分布</strong>和<strong>共轭先验分布</strong>。</p>
<h4 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a><strong>后验分布</strong></h4><p>在获得样本X后，θ的后验分布（Posterior Distribution）就是在给定X=x的条件下θ的条件分布，记为π(θ|x)。求后验分布用的是贝叶斯公式。</p>
<p><strong>1：连续型</strong></p>
<p>θ为连续型随机变量时，其后验分布的密度函数为：</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p>其中，h(x, θ) = f(x|θ)π(θ) 是X和θ的联合密度，f(x|θ) 是样本的概率密度函数。而m(x)：</p>
<script type="math/tex; mode=display">
m(x) =\int_{\theta}h(x,\theta)d\theta =\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)</script><p><strong>2：离散型</strong></p>
<p>当θ是离散型随机变量时，先验分布可用先验分布列｛π(θi)，i=1,2,…,n｝来表示，这时的后验分布是如下离散形式：</p>
<script type="math/tex; mode=display">
\pi(\theta_{i}|x) = \frac{f(x|\theta_i)\pi(\theta_i)}{\sum{f(x|\theta_i)\pi(\theta_i)}}</script><p>那么后验分布可以看做是人们用总体信息和样本信息（统称为抽样信息）对先验分布作调整的结果，是总体信息、样本信息和先验信息的综合。</p>
<h4 id="似然函数与共轭分布"><a href="#似然函数与共轭分布" class="headerlink" title="似然函数与共轭分布"></a><strong>似然函数与共轭分布</strong></h4><p><strong>1：似然函数</strong></p>
<p>对于后验分布计算公式中的f(x|θ)，从不同的角度看有不同的含义：</p>
<p>① 概率密度函数：若参数θ已知，而x是未知变量，那么描述的是不同样本点的概率，叫做概率密度函数。</p>
<p>② 似然函数：若x是已经确定的，而参数θ是变量，那么描述的是对于不同的参数θ，某一个样本出现的概率，一般写作l(θ|x)，叫做参数θ的似然函数。</p>
<p>从上面已知，后验分布 = 样本的密度函数×先验分布/边缘分布，也可以看做：后验分布 = 似然函数×先验分布/边缘分布。</p>
<p><strong>2：共轭分布</strong></p>
<p>已知后验分布 = 似然函数×先验分布/边缘分布，那么如果后验分布与先验分布有相同的形式，比如都服从贝塔分布，那么就称似然函数和先验分布是共轭的，互为共轭分布，先验分布是似然函数的共轭先验分布。</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p>如果计算出来的π(θ|x)和π(θ)有相同的分布类型，那么称f(x|θ)和π(θ)互为共轭分布，π(θ)是f(x|θ)的共轭先验分布。</p>
<p><strong>后验分布的简化计算</strong></p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)}\propto f(x|\theta)\pi(\theta)</script><p>符号∝表示“正比于”，即符号左边的式子和右边的式子只差了一个与参数θ无关的常数因子。<strong>π(θ|x) = 正则化因子 × {f(x|θ)的核} × {π(θ)的核}</strong></p>
<p>(我看到这里一头雾水？？？我有干什么来着？)</p>
<h3 id="最大似然估计和最大后验概率估计"><a href="#最大似然估计和最大后验概率估计" class="headerlink" title="最大似然估计和最大后验概率估计"></a>最大似然估计和最大后验概率估计</h3><hr>
<p>统计要解决的问题是，手头有一堆数据，要利用这堆数据去推测模型和参数，而最大似然估计和最大后验概率估计就是推断模型和参数的两种不同方法。</p>
<h4 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a><strong>最大似然估计</strong></h4><p>最大似然估计是求参数θ, 使似然函数p(X|θ)最大。<strong>频率学派</strong>采用最大似然估计来推断模型的参数。</p>
<p>最大似然估计的含义是根据已经采集到的样本，希望通过调整模型参数使得这些样本被选中的概率最大。</p>
<p>样本的似然函数为p(X|θ)，可以理解为已知样本集合X的情况下，所有样本点同时出现的概率，是关于参数θ的函数，因此最大似然估计就是要最大化似然函数。</p>
<p>最大似然估计的目标函数为：</p>
<script type="math/tex; mode=display">
p(X|\theta) = \prod^{xn}_{x1}p(xi|\theta) = \sum^{xn}_{x1}logp(xi|\theta)</script><h4 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a><strong>最大后验概率估计</strong></h4><p>最大后验概率估计则是想求参数θ，使p(x|θ)p(θ)，即后验概率最大。求得的θ不单让似然函数大，θ本身出现的先验概率也得大。贝叶斯学派采用最大后验概率估计来推断模型的参数。</p>
<p>最大后验概率估计的含义是基于对参数的一个先验假设，并根据已经收集到的样本，通过调整参数使得这些样本被选中的后验概率最大。模型参数本身满足某种分布，不再一味依赖数据样例。</p>
<p>如果以密度函数来进行计算，最大后验概率估计的目标函数就是：</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p><strong>联系和区别</strong></p>
<p>最大似然估计比较依赖较大的数据量和大数定律，在样本量较少时，参数估计的结果容易出现较大偏差。</p>
<p>最大后验概率估计允许我们把先验知识加入到估计模型中，这在样本很少的时候是很有用的。但是随着样本量的增大，参数估计的结果主要受数据量的影响，先验假设的影响会越来越小。</p>
<p>如果参数θ服从于均匀分布U(0,1)时，有先验概率为p(θ)=1，此时最大似然估计和最大后验概率估计是等价的。</p>
<p>看不明白也没啥大不了的，只是记录一下实际公式，应用可以看相关链接</p>
<p>(相关链接：<a href="https://cloud.tencent.com/developer/article/1640085">贝叶斯学派与频率学派</a>,·<a href="https://zhuanlan.zhihu.com/p/48071601">MLE&amp;MAP</a>)</p>
<h2 id="决策理论-博弈论"><a href="#决策理论-博弈论" class="headerlink" title="决策理论(博弈论)"></a>决策理论(博弈论)</h2><p>决策论背后的核心思想是<strong>最小化期望损失</strong> 。定义清楚期望损失，问题就转变成最优化问题，带入优化器，就迎刃而解了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>#</th>
<th style="text-align:right">实际值 0</th>
<th style="text-align:right">实际值 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>预测值 0</td>
<td style="text-align:right">00</td>
<td style="text-align:right">01</td>
</tr>
<tr>
<td>预测值 1</td>
<td style="text-align:right">10</td>
<td style="text-align:right">11</td>
</tr>
</tbody>
</table>
</div>
<p>(0 表示失败， 1表示成功; 01是最不能接受的结果，其次是10)</p>
<p>0-1损失：</p>
<script type="math/tex; mode=display">
L(y,\hat{y}) = I(y\not=\hat{y})= {0 \ \ \ if\ y = \hat{y}\choose 1\ \ \ \ else}</script><p>平方损失：</p>
<script type="math/tex; mode=display">
L(y,\hat y) = (y- \hat y)^2</script><h3 id="经验风险最小化"><a href="#经验风险最小化" class="headerlink" title="经验风险最小化"></a>经验风险最小化</h3><hr>
<p>上面我们提到了两种损失函数，根据机器学习的目标，损失函数值越小，模型就越好。由于模型的输入输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是：</p>
<script type="math/tex; mode=display">
R_{exp}(f) = E_p[L(Y,\hat y)]= \int L(y,\hat{y})P(y,\hat y) d\hat y dy</script><p>这是理论上的期望风险模型，但是联合分布究竟以何种形式我们是未知的，所以我们使用训练数据的平均损失作为近似值，也就是经验风险：</p>
<script type="math/tex; mode=display">
R_{emp}(f) = \frac{1}{N}\sum^N_{i=1}L(y_i,\hat y_i)</script><p>那么标题的经验风险最小化就很容易理解了，即经验风险最小的模型是最优的模型。(R_emp min)</p>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果。比如，<strong>极大似然估计</strong>（就是经验风险最小化的一个例子，<strong>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。</strong>(是古典学派的胜利啊)</p>
<h3 id="结构风险最小化"><a href="#结构风险最小化" class="headerlink" title="结构风险最小化"></a>结构风险最小化</h3><hr>
<p>结构风险最小化（structural minimization,  SRM）是为了防止过拟合提出的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。</p>
<script type="math/tex; mode=display">
R_{srm}(f) = R_{emp}+\lambda J(f)</script><p>J(f)是模型复杂度函数，入大于0是系数。</p>
<p>结构风险小需要经验风险和模型复杂度同时都小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</p>
<p>贝叶斯估计中的最大后验概率估计（maximum posterior probability  estimation,MAP）就是结构风险最小化的一个例子，当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。</p>
<p>相关链接：<a href="https://blog.csdn.net/pxhdky/article/details/83544932">经验风险最小化与结构风险最小化</a></p>
<h3 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h3><hr>
<p>可以看到我们在上面计算损失时，都是只用了训练数据本身，那很自然的想到，这种没有使用先验概率的想法是频率统计的风格。那贝叶斯决策，也就是在次基础上加上先验概率了。</p>
<script type="math/tex; mode=display">
\lambda^{(i)}_j = \lambda(\omega_i|\omega_j)\ \ \ (i,j=1,2,...,c)</script><p>表示将j类误判为i类的损失，c为类数。由λ构成一个c×c的损失矩阵，也即表示决策表。</p>
<p>最小风险贝叶斯决策的判决函数为：</p>
<script type="math/tex; mode=display">
minR_i(x) = \sum^c_{j=1}\lambda_j^{(i)}P(w_j|x)</script><h4 id="贝叶斯决策的一般过程"><a href="#贝叶斯决策的一般过程" class="headerlink" title="贝叶斯决策的一般过程"></a>贝叶斯决策的一般过程</h4><p>1）估计先验概率：①根据实际情况做经验估计；②根据样本分布的频率估计概率。</p>
<p>（2）计算类条件概率密度：①参数估计：类条件概率分布类型已知，参数未知，通过训练样本来估计（最大似然法、Bayes估计）；②非参数估计：不判断类条件概率分布类型，直接根据训练样本来估计（Parzen窗、kn-近邻法）。</p>
<p>（3）计算后验概率。</p>
<p>（4-1）若进行最小错误率决策，根据后验概率即可作出决策。</p>
<p>（4-2）若进行最小风险决策，使用上面公式</p>
<p>相关链接：<a href="https://www.cnblogs.com/hizhaolei/p/8196096.html">贝叶斯决策</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识整理</title>
    <url>/simon-blog.github.io/2020/08/14/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>问数据库的东西肯定问sql的，你说你会redics，你会nosql。好的，项目用过吗，请开始你的表演。还是老老实实和他谈关系型数据库吧。这其中一般时间都在问你索引，不想被面试官怼穿就老老实实复习吧。</p>
<a id="more"></a>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>如何查看某个语法</p>
<p>在query语句前面加？</p>
<p>值得注意的是需要和在query语句前加explain区分，后面会提到explain，简单说explain是用来检查语句执行效率的，主要看使用索引的效率。</p>
</li>
<li><p>MySQL储存引擎</p>
<p>MYISAM，Innodb，memory，merge，csv，…其他我也没听过了</p>
<p>常用的就两种，最多加一个memory</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>MYIsAM</th>
<th style="text-align:left">Innodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件</td>
<td>每个MyISAM在磁盘上存储成三个文件。第一个 文件的名字以表的名字开始，扩展名指出文件类型。<br/>.frm文件存储表定义。<br/>数据文件的扩 展名为.MYD (MYData)。<br/>索引文件的扩 展名是.MYI (MYIndex)。<br/> 因为使用的是非簇集索引</td>
<td style="text-align:left">基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的 大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td>事务处理</td>
<td>MyISAM类型的表强调的是性能，其执行数 度比InnoDB类型更快，但是不提供事务支持 <br/> 如果执行大量的SELECT，MyISAM是更好的选择。</td>
<td style="text-align:left">InnoDB提供事务支持事务，外部键等高级 数据库功能.如果在应用中执行大量insert和update操作，应该选择InnoDB。清空整个表时，InnoDB是一行一行的删除，效率非常慢。</td>
</tr>
<tr>
<td>锁</td>
<td>表锁</td>
<td style="text-align:left">提供行锁(locking on row level)，提供与 <a href="http://www.ha97.com/category/database/oracle-database">Oracle</a> 类型一致的不加锁读取(non-locking read in<br/>SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执 行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</td>
</tr>
<tr>
<td>表的行数</td>
<td>MyISAM只要简单的读出保存好的行数即可。</td>
<td style="text-align:left">InnoDB需要扫描一遍整个表来计算有多少行</td>
</tr>
</tbody>
</table>
</div>
<p>   基本的差别为：</p>
<p>   MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。</p>
<p>   MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。MyISAM缓存在内存的是索引，不是数据。而InnoDB缓存在内存的是数据，相对来说，服务器内存越大，InnoDB发挥的优势越大。</p>
<p>   Innodb是事务安全的。AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。</p>
<ol>
<li><p>选择合适的数据类型</p>
<ol>
<li>MyISAM 数据存储引擎和数据列 MyISAM数据表，最好使用固定长度的数据列代替可变长度的数据列。</li>
<li>MEMORY存储引擎和数据列 MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。</li>
<li>InnoDB 存储引擎和数据列 建议使用 VARCHAR类型  对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列(所有数据行 都使用指向数据列值的头指针)  ，因此在本质上，使用固定长度的CHAR列不一定比使 用可变长度VARCHAR列简单。 因而， 主要的性能因素是数据行使用的存储总量。 由于  CHAR 平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总 量和磁盘I/O是比较好的。</li>
</ol>
</li>
<li><p>ID自增不连续</p>
<p>唯一键冲突是导致自增主键id不连续的第一种原因</p>
<p>事务回滚是导致自增主键id不连续的第二种原因</p>
<p>批量申请自增id的策略是导致自增主键id不连续的第三种原因</p>
<p>解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table name auto_increment &#x3D; 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3NF</p>
<ul>
<li>1NF 指的是数据库表中的任何属性都具有原子性的，不可再分解</li>
<li>2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性</li>
<li>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余</li>
</ul>
</li>
<li><p>事务4个特性</p>
<ul>
<li><strong>原子性 Atomicity：</strong>一个事务中的所有操作，要么全部完成，要么全部不完成，最小的执行单位。</li>
<li><strong>一致性 Consistency：</strong>事务执行前后，都处于一致性状态。</li>
<li><strong>隔离性 Isolation：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>
<li><strong>持久性 Durability：</strong>事务执行完成后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</li>
<li><p>事务的隔离等级</p>
<ul>
<li>READ_UNCOMMITTED 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。</li>
<li>READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题</li>
<li>REPEATABLE_READ 保证一个事务相同条件下前后两次获取的数据是一致的 （注意是 一个事务，可以理解为事务间的数据互不影响）解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。</li>
<li>SERIALIZABLE 事务串行执行，解决了脏读、不可重复读、幻读。但效率很差，所以实际中一般不用。</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li><p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p>
</li>
<li><p>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p>
</li>
<li><p>环路等待条件：在发生死锁时，必然存在一个进程—资源的环形链。</p>
<p>怎么解决：</p>
<ul>
<li>设置超时时间。超时后自动释放。</li>
<li>发起死锁检测，主动回滚其中一条事务，让其他事务继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>创建用户，授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL删除方式</p>
<ul>
<li>delete : 仅删除表数据，支持条件过滤，支持回滚。记录日志。因此比较慢。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>truncate: 仅删除所有数据，不支持条件过滤，不支持回滚。不记录日志，效率高于delete。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>drop:删除表数据同时删除表结构。将表所占的空间都释放掉。删除效率最高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MVVC</p>
<p>MVCC 全称是多版本并发控制系统，InnoDB 的 MVCC  是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version  number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
</li>
<li><p>MySQL使用流程</p>
<p>客户端连接数据库，验证身份。</p>
<p>获取当前用户权限。</p>
<p>当你查询时，会先去缓存看看，如果有返回。</p>
<p>如果没有，分析器对sql做词法分析。</p>
<p>优化器对sql进行“它认为比较好的优化”。</p>
<p>执行器负责具体执行sql语句。</p>
<p>最后把数据返回给客户端。</p>
</li>
<li><p>视图</p>
<p>视图(View)是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并 不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时 动态生成的。</p>
<p>视图相对于普通的表的优势主要包括以下几项。</p>
<ul>
<li>简单:使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件， 对用户来说已经是过滤好的复合条件的结果集。</li>
<li>安全:使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能 限制到某个行某个列，但是通过视图就可以简单的实现。</li>
<li>数据独立:一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加 列对视图没有影响;源表修改列名，则可以通过修改视图来解决，不会造成对访问 者的影响。</li>
</ul>
</li>
<li><p><strong>Explain的用法</strong></p>
</li>
</ol>
<pre><code>| column          | meaning                |
| --------------- | ---------------------- |
| id              | 查询序号               |
| **select_type** | join类型               |
| table           | 表名                   |
| partitions      | 匹配的分区             |
| **type**        | 查询类型               |
| possible_keys   | 可能选择的索引         |
| key             | 实际选择的索引         |
| key_len         | 索引长度               |
| ref             | 与索引比较的列         |
| rows            | 要检查的行数（估算值） |
| filtered        | 查询条件过滤行数百分比 |
| Extra           | extra                  |
</code></pre><ol>
<li><p>select_type参数</p>
<p><img src="https://s1.ax1x.com/2020/08/14/die76J.jpg" alt="die76J.jpg"></p>
</li>
<li><p>type参数</p>
<p>这是<strong>最重要的字段之一</strong>，显示查询使用了何种类型。从最好到最差的连接类型依次为：</p>
<blockquote>
<p>system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL</p>
</blockquote>
<p>1、system</p>
<p>表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p>
<p>2、const</p>
<p>最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描</p>
<p>3、eq_ref</p>
<p>多表join时，对于来自前面表的每一行，在当前表中只能找到一行。这可能是除了system和const之外最好的类型。当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型。</p>
<p>eq_ref可用于使用’=’操作符作比较的索引列。比较的值可以是常量，也可以是使用在此表之前读取的表的列的表达式。</p>
<blockquote>
<p>相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。 eq_ref只能找到一行，而ref能找到多行。</p>
</blockquote>
<p>4、ref</p>
<p>对于来自前面表的每一行，在此表的索引中可以匹配到多行。若联接只用到索引的最左前缀或索引不是主键或唯一索引时，使用ref类型（也就是说，此联接能够匹配多行记录）。</p>
<p>ref可用于使用’=’或’&lt;=&gt;’操作符作比较的索引列。</p>
<p>5、 fulltext</p>
<p>使用全文索引的时候是这个类型。要注意，<strong>全文索引的优先级很高</strong>，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
<p>6、ref_or_null</p>
<p>跟ref类型类似，只是增加了null值的比较。实际用的不多。</p>
<p>7、index_merge</p>
<p>表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如range</p>
<p>8、unique_subquery</p>
<p>用于where中的in形式子查询，子查询返回不重复值唯一值，可以完全替换子查询，效率更高。 该类型替换了下面形式的IN子查询的ref：  value IN (SELECT primary_key FROM single_table WHERE some_expr)</p>
<p>9、index_subquery</p>
<p>该联接类型类似于unique_subquery。适用于非唯一索引，可以返回重复值。</p>
<p>10、range</p>
<p>索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。</p>
<p>11、index</p>
<p>索引全表扫描，把索引从头到尾扫一遍。这里包含两种情况：  一种是查询使用了覆盖索引，那么它只需要扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在extra中显示Using index，反之，如果在索引上进行全表扫描，没有Using index的提示。</p>
<p>12、all</p>
<p>全表扫描，性能最差。</p>
</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>关于索引的部分请参考下一篇文章，都写在一起实在有点多啊。</p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引知识</title>
    <url>/simon-blog.github.io/2020/08/14/MySQL%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>书说上文，我们讲完了常见mysql问题，接下来我们来谈一谈他的索引。甚至你不去了解上一章的常见问题，你也要看完这一章的索引。对于数据库来说索引这样一个优秀的储存结构可以说是尤为重要。</p>
<a id="more"></a>
<ol>
<li><p>创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);</span><br><span class="line">或者</span><br><span class="line">CREATE INDEX index_name ON my_table(column_name);</span><br></pre></td></tr></table></figure>
<p>索引本身也要占空间，也可以把索引本身看作一张表</p>
<p>创建索引时需要锁表，注意是表锁。索引创建时本身也要全表搜索？</p>
</li>
<li><p>索引用法</p>
<p>具体查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE column_1&#x3D;column_2;(为column_1建立了索引)</span><br><span class="line"></span><br><span class="line">或者模糊查询</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</span><br><span class="line"></span><br><span class="line">如果要表示在字符串中既有A又有B，那么查询语句为：</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;A%&#39; AND column_1 LIKE &#39;B%&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;[张李王]三&#39;;  &#x2F;&#x2F;表示column_1中有匹配张三、李三、王三的都可以</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;[^张李王]三&#39;;  &#x2F;&#x2F;表示column_1中有匹配除了张三、李三、王三的其他三都可以</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示其中的某一个字符；[^]表示除了其中的字符的所有字符</span><br><span class="line"></span><br><span class="line">或者在全文索引中模糊查询</span><br><span class="line">SELECT * FROM table_name WHERE MATCH(content) AGAINST(&#39;word1&#39;,&#39;word2&#39;,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX my_index ON tablename；</span><br><span class="line">或者</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p>查看表中的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM tablename</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>索引分类</strong></p>
<p><strong>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</strong></p>
<ul>
<li><p>主键索引：非空唯一，只要建立主键就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alter table &#39;test&#39; add primary key pk_index(&#39;col&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>唯一索引：唯一，可以有多列，可以为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通索引：可不唯一，可为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>全文索引：对于大面积字符串统计出现单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合索引：多列组合为一个索引，列中不许出现空值。遵循最左前缀原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>索引原理</strong></p>
<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如<strong>BTree索引，B+Tree索引，哈希索引，全文索引</strong>等等**。</p>
<p><strong>1、哈希索引：</strong></p>
<p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p>
<p><strong>2、全文索引：</strong></p>
<p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，因为没使用索引。这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加。</p>
<p><strong>3、BTree索引和B+Tree索引</strong></p>
<h4 id="画重点了啊！"><a href="#画重点了啊！" class="headerlink" title="画重点了啊！"></a>画重点了啊！</h4><p>首先还是从二叉树谈起吧。B+树索引是B+树在<a href="http://lib.csdn.net/base/mysql">数据库</a>中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkCNdO.png" alt="dkCNdO.png"></p>
<p>这就是一个二插搜索数，左子树的键值小于根的键值，右子树的键值大于根的键值。 但是，如果增删过一段时间后，可能就变成了下图。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkC0Wd.png" alt="dkC0Wd.png"></p>
<p>这样效率就与链表无异了，所以在这基础上又有了平衡二叉树（AVL Tree), 而里面又诞生了红黑树。主要就是确保增删查改的复杂度都能维持在logn。这样在数据很多的情况下，二叉树遇到了信息量不足的瓶颈，因为再怎么样，一个node也只能知道他的左右节点。但是这已经是二叉树的极限了，聪明的人就想出，既然二叉能保存的信息有限，那我就用多叉树好了。也就是所谓的多路查找平衡树，B-Tree。</p>
<p>同时我们要改变另一个概念，好多人问他为什么用索引，他就说能快速找到数据，你问他为啥，他也会告诉你，因为用b树，b+树搜索变快了，从n变成了logn。但仔细想一想红黑数也可以啊，为什么一定是多路搜索树呢？那就要从另一个角度去看问题。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在<a href="http://lib.csdn.net/base/mysql">MySQL</a>中可通过如下命令查看页的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_page_size&#39;;</span><br></pre></td></tr></table></figure>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会<strong>减少磁盘I/O次数</strong>，提高查询效率。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkApCD.png" alt="dkApCD.png"></p>
<p><strong>B+Tree</strong></p>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkFQJg.png" alt="dkFQJg.png"></p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 <em> 10^3 </em> 10^3 = 10亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。<a href="http://lib.csdn.net/base/mysql">mysql</a>的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
<p><strong>B+Tree对比BTree的优点：</strong></p>
<ul>
<li>磁盘读写代价更低</li>
</ul>
<p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p>
<ul>
<li>查询速度更稳定</li>
</ul>
<p>由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。</p>
</li>
<li><p><strong>聚簇索引和非聚簇索引</strong></p>
<h4 id="第二个重点啊"><a href="#第二个重点啊" class="headerlink" title="第二个重点啊"></a>第二个重点啊</h4><p>分析了MySQL的索引结构的实现原理，然后我们来看看具体的存储引擎怎么实现索引结构的，MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p>
<p>聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序</p>
<p>非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</p>
<p><strong>MyISAM——非聚簇索引</strong></p>
<ul>
<li>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。</li>
<li>非聚簇索引的数据表和索引表是分开存储的。</li>
<li>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</li>
</ul>
<p><strong>InnoDB——聚簇索引</strong></p>
<ul>
<li>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。</li>
<li>聚簇索引的数据和主键索引存储在一起。</li>
<li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。</li>
<li>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</li>
</ul>
<p>使用主索引的时候，更适合使用聚簇索引，因为聚簇索引只需要查找一次，而非聚簇索引在查到数据的地址后，还要进行一次I/O查找数据。</p>
<p>因为聚簇辅助索引存储的是主键的键值，因此可以在数据行移动或者页分裂的时候降低成本，因为这时不用维护辅助索引。但是由于主索引存储的是数据本身，因此聚簇索引会占用更多的空间。</p>
<p>聚簇索引在插入新数据的时候比非聚簇索引慢很多，因为插入新数据时需要检测主键是否重复，这需要遍历主索引的所有叶节点，而非聚簇索引的叶节点保存的是数据地址，占用空间少，因此分布集中，查询的时候I/O更少，但聚簇索引的主索引中存储的是数据本身，数据占用空间大，分布范围更大，可能占用好多的扇区，因此需要更多次I/O才能遍历完毕。</p>
<p><a href="https://imgchr.com/i/dkZaRS"><img src="https://s1.ax1x.com/2020/08/15/dkZaRS.jpg" alt="dkZaRS.jpg"></a></p>
</li>
<li><p><strong>索引的使用测略</strong></p>
<h4 id="第三个重点"><a href="#第三个重点" class="headerlink" title="第三个重点"></a>第三个重点</h4><p><strong>什么时候要使用索引？</strong></p>
<ul>
<li>主键自动建立唯一索引；</li>
<li>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；</li>
<li>作为排序的列要建立索引；</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>高并发条件下倾向组合索引；</li>
<li>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</li>
</ul>
<p><strong>什么时候不要使用索引？</strong></p>
<ul>
<li>经常增删改的列不要建立索引；</li>
<li>有大量重复的列不建立索引；</li>
<li>表记录太少不要建立索引。只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快—不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。</li>
</ul>
<p><strong>索引失效的情况：</strong></p>
<ul>
<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>
<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>
<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>
<li>在索引的列上使用表达式或者函数会使索引失效，例如：select <em> from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select </em> from users where adddate&lt;’2007-01-01′。其它通配符同样，也就是说，在查询条件中使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。</li>
<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（经erwkjrfhjwkdb同学提醒，不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>
<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>
<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败，应该改为WHERE email=’99999’。</li>
<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。</li>
<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>
<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引；</li>
</ul>
</li>
</ol>
<p>   Tips：</p>
<p>   1、最左前缀</p>
<p>   索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引<col1,col2,col3>那么以下3中情况可以使用索引：col1，<col1,col2>，<col1,col2,col3>，其它的列，比如<col2,col3>，<col1,col3>，col2，col3等等都是不能使用索引的。</p>
<p>   根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。</p>
<p>   2、带索引的模糊查询优化</p>
<p>   在上面已经提到，使用LIKE进行模糊查询的时候，’%aaa%’不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化（上文有讲到）。</p>
<p>   3、为检索的条件构建全文索引，然后使用</p>
<blockquote>
<p>SELECT * FROM tablename MATCH(index_colum) ANGAINST(‘word’);</p>
</blockquote>
<p>   4、使用短索引</p>
<p>   对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
<p>相关文章:</p>
<p><a href="https://www.jianshu.com/p/c82148473235">无语，我差点被面试官怼坏了，又给我问到MySQL索引</a></p>
<p><a href="https://www.cnblogs.com/vianzhang/p/7922426.html">BTree和B+Tree详解</a>         </p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识整理</title>
    <url>/simon-blog.github.io/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>面试3板斧， 数据库，操作系统，计算机网络。 什么你说语言？这个，不同岗位面不同语言吗，但上面这三个是跑不掉的。索性计算机网络需要掌握的没有数据库来的多。</p>
<a id="more"></a>
<ol>
<li><p>网络结构</p>
<p>OSI 7层：拆分应用层，额外分出表示层，会话层</p>
<p>TCP/IP 4层：应用层，传输层，网际层，网络以下一层</p>
<p>5层结构：物理层，链路层</p>
<ul>
<li><strong>1. 应用层</strong></li>
</ul>
<p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<ul>
<li><strong>2. 运输层</strong></li>
</ul>
<p>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<ul>
<li><strong>3. 网络层</strong></li>
</ul>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<ul>
<li><strong>4. 数据链路层</strong></li>
</ul>
<p>数据链路层（data link  layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<ul>
<li><strong>5. 物理层</strong></li>
</ul>
<p>在物理层上所传送的数据单位是比特。物理层（physical  layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkaRfS.jpg" alt="dkaRfS.jpg"></p>
</li>
</ol>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ol>
<li><p>APR协议工作原理</p>
<p>IP地址到mac地址。</p>
<p>​    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。                                   </p>
<p>​     2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：<strong>源主机IP地址，源主机MAC地址，目的主机的IP地址</strong>。                                   </p>
<p>​      3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。                                                                                                                        </p>
<p>​      4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dk4gzj.png" alt="dk4gzj.png">                                                               </p>
</li>
<li><p>IP协议</p>
<p><strong>互联网协议地址</strong>（英语：Internet Protocol Address，又译为<strong>网际协议地址</strong>），缩写为<strong>IP地址</strong>（英语：IP Address），是分配给用户上网使用的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/IPv4">IPv4</a>与<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/IPv6">IPv6</a>两大类，但是也有其他不常用的小分类。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkIpBq.jpg" alt="dkIpBq.jpg"></p>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li>
</ul>
</li>
<li><p>IP地址分类</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkImuR.jpg" alt="dkImuR.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkI058.jpg" alt="dkI058.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkIs2Q.jpg" alt="dkIs2Q.jpg"></p>
</li>
</ol>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP（Transmission Control Protocol <a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/9727741">传输控制协议</a>）是一种面向连接的、可靠的、基于字节流的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536">传输层</a>通信协议，由IETF的RFC 793定义。</p>
<ol>
<li><p>主要特点</p>
<p>\1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
<p>\2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</p>
<p>\3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
<p>\4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
<p>\5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</li>
<li><p>TCP如何保证传输可靠</p>
<ul>
<li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
</li>
<li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
</li>
<li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</p>
</li>
<li><p><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
</li>
<li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</li>
<li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<ul>
<li><p>具体的，滑动窗口：<strong>接收窗口只会对窗口内最后一个按序到达的字节进行确认</strong></p>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31  进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkTgA0.jpg" alt="dkTgA0.jpg"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>壅塞控制</p>
<p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。<strong>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkTvge.jpg" alt="dkTvge.jpg"></p>
<p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：  A、慢启动  B、拥塞避免  C、快重传  D、快恢复</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。<strong>具体发送数量，哪个小用哪个。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dk7hIP.jpg" alt="dk7hIP.jpg"></p>
</li>
<li><p>三次握手</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkHkZR.jpg" alt="dkHkZR.jpg"></p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p>
<p>一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。</p>
<p><strong>第一次握手</strong>：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位  SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1  的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p><strong>第二次握手</strong>：B  收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x +  1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入  SYN-RCVD（同步收到）状态。</p>
<p><strong>第三次握手</strong>：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置  1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK  报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<ul>
<li><p>为什么不能两次握手</p>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A  发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达  B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A  发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<p>本来收到消息后就该发ACK，这是快速回复机制。而且三次握手都没挡住ddos攻击，何况两次</p>
</li>
<li><p>为什么不需要4次？</p>
<p>在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</p>
<p>同理，你可以反问对方为什么不需要5次。</p>
</li>
<li><p>Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN</p>
<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
</li>
<li><p>传了SYN为什么还需要ACK</p>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
</li>
</ul>
</li>
<li><p>四次挥手</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkbR4P.jpg" alt="dkbR4P.jpg"></p>
<p><strong>第一次挥手</strong>：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位  FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入  FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p>
<p><strong>第二次挥手</strong>：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B  前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP  服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A  收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p>
<p><strong>第三次挥手</strong>：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入  LAST-ACK(最后确认)状态，等待 A 的确认。</p>
<p><strong>第四次挥手</strong>：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号  seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP  连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED  状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED  状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
<ul>
<li><p>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢</p>
<ol>
<li><p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B  收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 +  1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到  CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
</li>
<li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
</li>
<li><p>为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么</p>
<p>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</p>
</li>
<li><p><strong>保活计时器的作用</strong></p>
<p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP  连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
</li>
</ul>
</li>
<li><p>TCP粘包</p>
<ol>
<li><p>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
</li>
<li><p>从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p>
</li>
</ol>
<p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<ul>
<li><strong>发送方产生粘包</strong></li>
</ul>
<p>采用 TCP  协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle  算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<ul>
<li><strong>接收方产生粘包</strong></li>
</ul>
<p>接收方采用 TCP  协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP  协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read  等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<ul>
<li><p>怎么解决</p>
<ol>
<li><p>特殊字符控制；</p>
</li>
<li><p>在包头首都添加数据包的长度。</p>
</li>
<li>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ol>
<li><p>TCP和UDP的区别</p>
<ol>
<li>TCP面向连接，传输数据之前要需要建立会话。UDP是无连接的。</li>
<li>TCP提供可靠传输，保证数据不丢包、不重复且按顺序到达；UDP只尽努力交付，不保证可靠交付</li>
<li>TCP提供了拥塞控制；UDP不提供</li>
<li>TCP是面向字节流的；UDP面向报文。</li>
<li>TCP只支持点到点通信；UDP支持一对一、一对多、多对多的交互通信。</li>
<li>TCP首部开销大20字节，UDP首部开销小8字节。</li>
</ol>
</li>
<li><p>UDP首部格式</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkOKht.jpg" alt="dkOKht.jpg"></p>
<p>反观TCP的报文头：没有长度！</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkOY7j.jpg" alt="dkOY7j.jpg"></p>
</li>
<li><p>对应应用</p>
<p><strong>1). TCP对应的应用层协议</strong></p>
<ul>
<li>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
<li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li>
<li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li>
<li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li>
<li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<p><strong>2). UDP对应的应用层协议</strong></p>
<ul>
<li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li>
<li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
</ul>
</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote>
<p><strong>超文本传输协议</strong>（<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英语</a>：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB">缩写</a>：<strong>HTTP</strong>）是一种用于分布式、协作式和<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>信息系统的<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层协议</a><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%23cite_note-ietf2616-1">[1]</a>。HTTP是<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>的数据通信的基础。</p>
</blockquote>
<p>HTTP协议定义了浏览器（即互联网客户进程）怎样向万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP是面向事务的应用层协议，它是万维网能够可靠的交付文件的重要基础。</p>
<ul>
<li>HTTP构建于TCP/IP协议之上，默认端口号是80</li>
<li>HTTP是<strong>无连接无状态</strong>的</li>
</ul>
<ol>
<li><p>状态码</p>
<ul>
<li><strong>1XX 信息</strong></li>
</ul>
<ol>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。HTTP1.1</li>
</ol>
<ul>
<li><strong>2XX 成功</strong></li>
</ul>
<ol>
<li><p>200 OK</p>
</li>
<li><p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ol>
<ul>
<li><strong>3XX 重定向</strong></li>
</ul>
<ol>
<li><p>301 Moved Permanently ：永久性重定向；</p>
</li>
<li><p>302 Found ：临时性重定向；</p>
</li>
<li><p>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li><p>304 Not Modified  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li><p>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ol>
<ul>
<li><strong>4XX 客户端错误</strong></li>
</ul>
<ol>
<li><p>400 Bad Request ：请求报文中存在语法错误。</p>
</li>
<li><p>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p>403 Forbidden ：请求被拒绝。</p>
</li>
<li><p>404 Not Found</p>
</li>
</ol>
<ul>
<li><strong>5XX 服务器错误</strong></li>
</ul>
<ol>
<li><p>500 Internal Server Error ：服务器正在执行请求时发生错误；</p>
</li>
<li><p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ol>
</li>
<li><p>forward 和 redirect 的区别？</p>
<p>Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。</p>
<p>直接转发方式（Forward）：<strong>客户端和浏览器只发出一次请求</strong>，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</p>
<p>间接转发方式（Redirect）：<strong>实际是两次 HTTP 请求</strong>，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</p>
</li>
<li><p>RESTFUL方法</p>
<ol>
<li><p>GET：获取资源，当前网络中绝大部分使用的都是 GET；</p>
</li>
<li><p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>DELETE：删除资源</p>
</li>
</ol>
</li>
<li><p>GET 和 POST 的区别</p>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<p>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p>
<ol>
<li><p>从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</p>
</li>
<li><p>从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</p>
</li>
<li><p>从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL  和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为  application/x-www-form-urlencoded MIME  字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中  ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</p>
</li>
<li><p>就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</p>
</li>
<li><p>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p>
</li>
</ol>
</li>
<li><p>POST和PUT</p>
<p>有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p>
<p>在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。 </p>
</li>
<li><p>在浏览器中输入 URL 地址到显示主页的过程</p>
<ol>
<li><p>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS  缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS  服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地  DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP  地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
</li>
<li><p>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</p>
</li>
<li><p>发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</p>
</li>
<li><p>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
</li>
<li><p>浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
<li><p>连接结束。</p>
</li>
</ol>
</li>
<li><p>整个网络请求的优化，尤其是对http</p>
<ul>
<li>DNS预解析，由浏览器提供，通过预加载一些域名，提前去做DNS解析，加快响应速度。</li>
<li>域名收敛，由服务器统一汇总不同的域名，由再对访问进行转发。</li>
<li>资源内联，由于每个资源首次访问都存在握手等RTT损耗，越少数量的资源请求，可以节约获取资源的时间，例如一个html中src访问一个css，就不如，将这个css直接以style集成在html当中，会减少访问。（webpack等一些构建工具，也可以将html与css当到一个文件当中。）</li>
<li>SSR，并非抽卡，而是服务器加载，传统的方式显示一个页面会发送多次请求，第一次拿到html资源，然后通过请求，再去拿数据，再将数据渲染到页面上。这样的多次请求，会增加页面的响应时间，如果在服务器端，就将页面渲染好，再发送至客户端，也可以间接减少RTT。即（react等框架的SSR）</li>
<li>图片懒加载，没看到的地方先不管</li>
<li>HTTP2,下面有说</li>
</ul>
</li>
<li><p>DNS</p>
<p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dAFGuR.jpg" alt="dAFGuR.jpg"></p>
<ol>
<li><p>HTTP 1.0,1.1,2.0</p>
<ul>
<li><strong>HTTP1.1 的主要变化：</strong></li>
</ul>
<ol>
<li><p>HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。</p>
</li>
<li><p>然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。</p>
</li>
<li><p>HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。</p>
</li>
</ol>
<ul>
<li><strong>HTTP2.0 的主要变化：</strong></li>
</ul>
<ol>
<li><p>HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；</p>
</li>
<li><p>HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；</p>
</li>
<li><p>HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；</p>
</li>
<li><p>HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/j_bleach/article/details/75215499">http请求过程及性能优化分析</a></p>
<p><a href="https://www.zhihu.com/column/c_1093515208294834176">计算机网络基础知识</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/84316213">计算机网络太难？了解这一篇就够了</a></p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（二）</title>
    <url>/simon-blog.github.io/2020/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><p>核心思想，不论是进行分类还是寻找模型，我都去寻找一个形如 y= kx +b的形式去描述我的模型，可以拓展为如下表达式：</p>
<script type="math/tex; mode=display">
f(x) = w_1x_1+w_2x_2+...+w_dx_d+b</script><p>向量表示为：</p>
<script type="math/tex; mode=display">
f(x) = w^Tx+b</script><p>这就是我理解的线性模型。同时，没有一个评判标准的话，我们是没有办法比较模型的好坏的，所以这里我们认为</p>
<p>当训练出来的模型f(x)和真实值y之间的误差最小时，方差误差，</p>
<script type="math/tex; mode=display">
min\sum(y-\hat y_i)^2</script><p>对应于训练出来的模型f(x)和真实值y之间欧几里得距离或称“欧氏距离”（Euclidean distance）最小时，该线性回归模型就是我们要的，此时我们称之为函数收敛。</p>
<h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><p>最小二乘法就是试图找到一条直线，使所有样本到直线的欧氏距离之和最小 (sum of square) 。 具体推导懒得写了，用mathjax写公式很累啊，简单说就是对w求导。可以去看看南瓜书</p>
<script type="math/tex; mode=display">
\omega = \frac{\sum(x_i-\overline x)(y_i-\overline y)}{\sum(x_i-\overline x)}</script><script type="math/tex; mode=display">
b = \overline y - \omega \overline x</script><h3 id="广义线性模型"><a href="#广义线性模型" class="headerlink" title="广义线性模型"></a>广义线性模型</h3><p>线性回归函数可以简写为：y = wx + b，这是用模型的预测值去逼近真实标记y。那么我们能不能令预测值去逼近y的衍生物呢？基于这样的考虑，我们就得到了线性回归的各种变型函数。给算式左边的y套上一层单调连续递增的函数。比如：ln(y) = wx + b</p>
<p><img src="https://s1.ax1x.com/2020/08/16/dVmDWq.png" alt="dVmDWq.png"></p>
<p>更一般地，考虑单调可微函数g，令：</p>
<script type="math/tex; mode=display">
g(y) = \omega x +b</script><p>这样得到的模型称为“广义线性模型”（generalized linear model），其中函数g称为“联系函数”（link function）。不同的联系函数会构成不同的线性回归模型。广义线性模型的参数估计常通过加权最小二乘法或极大似然估计法进行。</p>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>有的时候我们的模型不以一个连续的概率情况出现，如果他只是一个二分的机器，只有是否这两个结果，那么看起来我们似乎不能用线性模型表示了，因为显然是否这样的一个函数是分段的，换言之他不连续，不能用一条直线表示。 但根据广义线性模型，我们似乎有了很好的替代品。</p>
<script type="math/tex; mode=display">
g(y) = ln(\frac{y}{1-y})</script><p>我们得到了“对数几率回归”（logit regression），也称“逻辑回归函数”。通过联系函数，我们可以看出该模型实际上是在用线性回归模型的预测结果去逼近真实标记的对数几率。</p>
<p><img src="https://s1.ax1x.com/2020/08/16/dVKkJs.png" alt="dVKkJs.png"></p>
<p>同样我们需要确定w和b，我们将y视为后验概率估计p(y=1|x)，则</p>
<p><img src="https://s1.ax1x.com/2020/08/16/dVMn1I.png" alt="dVMn1I.png"></p>
<p>显然</p>
<p><img src="https://s1.ax1x.com/2020/08/16/dVM8Ag.png" alt="dVM8Ag.png"></p>
<p>于是，我们可通过“极大似然法” (maximum likelihood method) 来估计w和b。即令每个样本属于其真实标记的概率越大越好。</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>设想一下怎么下山最快，那当然是找最陡峭的地方往下走。也可以简单理解为求导，找当前点的切线，沿着切线方向走。</p>
<p>梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。</p>
<script type="math/tex; mode=display">
\theta^1 = \theta^0 - \triangle J(\theta) \ \ \ \ \ evaluated \ at\ \theta^0</script><p>α是什么含义？<br> α在梯度下降算法中被称作为<strong>学习率</strong>或者<strong>步长</strong>，意味着我们可以通过α来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈，其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p>
<p>按照课件里提到的，可以用牛顿法寻找，不一定只用求导。</p>
<p>优化过的牛顿法，Iteratively reweighted least squares (IRLS)</p>
<p>所以说梯度下降作为一个工具是给我们找最小值，之前哪里用到了最小值呢？线性模型，使用方差误差的最小值来确定线性模型，显然使用梯度下降方法能够帮我找到收敛后的线性模型（指w和d）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学校</tag>
      </tags>
  </entry>
</search>
