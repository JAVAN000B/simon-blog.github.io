<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/simon-blog.github.io/2020/08/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>python元类和装饰器</title>
    <url>/simon-blog.github.io/2020/08/08/python%E5%85%83%E7%B1%BB%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h2><p>动态添加函数功能，相当于在原函数上套了一层皮，动态添加新的职责。比如Django，flask里的@session现在终于是弄明白那一块用户身份验证的原理了。（在原来的view函数上使用装饰者模式，如果http请求里包含了session的ID就允许render，从而实现一些页面对于用户的隐藏）</p>
<a id="more"></a>

<p>相关的身份验证代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(f)        # 这里的@开头的部分就是一个装饰器，虽然他不是重点，只是用来确保原函数属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure>

<p>可能这样看并不明显，那么接下来两个例子就很好的说明了他的具体用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>

<p>a_new_decorator 这个函数以另一个函数为变量，a_function_requiring_decoration在使用装饰函数包裹他之后，他的输出就额外多出了两行。但是这并不是decorator的典型写法，下面才是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>

<p>使用@开始一个装饰器，非常的优雅。同时装饰器并不是只能这么笨重的使用，他也是函数，他也是对象。那么他就可以附加额外的参数，甚至你可以定义一个装饰器类。当然这里就不展开细讲了。详细可以左转</p>
<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python装饰器函数</a> </p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>可以创建类的类，听起来是不是很像工厂模式？虽然很像，但他可不只单单可以创建类那么简单，甚至可以修改已经创建好的类的属性。</p>
<p>正常的创建类的方式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = type(<span class="string">&#x27;Myclass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>使用元类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMeta</span>(<span class="params">type</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用元类实现给类添加属性 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, attrs</span>):</span></span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(mcs, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>(<span class="params">list, metaclass=ListMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">l = MyList()</span><br><span class="line">l.add(<span class="number">1</span>)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<p>你可能会奇怪，怎么写的这么别扭，还用了lamda函数，就往原来的类里面加了个add方法，那我用装饰器不就好了。U1S1,QS. 但是，元类绝对不是这么鸡肋的存在。我所了解的，Django，flask这些框架使用的ORM就是基于元类，对于model类的动态控制，来实现mysql语句的更新和管理使用到的数据。同时，元类还可以用于创建python里的单列模式。（但python所有东西都是对象，真的有必要单列吗）</p>
<h2 id="类的new-和-init"><a href="#类的new-和-init" class="headerlink" title="类的new__和__init"></a>类的<strong>new__和__init</strong></h2><p>惊了，markdown打不出来__new__方法吗，会变成加粗字体。嘛，反正你们也知道我在说什么吧。</p>
<p>一般在python里__new__方法创建实例，__init__负责初始化一个实例。__new__方法返回创建的对象，而__init__方法禁止返回值(必须返回None)。有一个简单的原则来判断什么使用使用__init__和__new__：</p>
<ul>
<li>如果需要修改类的属性，使用元类的__new__方法</li>
<li>如果只是做一些类属性检查的工作，使用元类的__init__方法</li>
<li>如果 new 方法不返回对象， 则不会调用 init 函数</li>
</ul>
<p>我能想到的这部分知识就先整理成这样吧，如果想起来还会加的。最后放一下参考的文章</p>
<p><a href="https://blog.csdn.net/kisslotus/article/details/83793781#4___new____init___132">Python 高级编程之元类和装饰器</a> </p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>常见网络攻击</title>
    <url>/simon-blog.github.io/2020/08/08/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前总结了网络的一些知识点，大概可以用网络的4层协议模型概括。虽然前博客的数据没了，但我会从新写一遍。今天就先来看一下之前没提到的网络安全这一块吧，也算是给自己查漏补缺了。</p>
<a id="more"></a>

<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><hr>
<p>这个相信大家肯定都有所耳闻，以前我天真的以为就是在url的后面加上<code>or 1=1</code>显然并不是这样。在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。比如你输入用户名密码登录时，你将请求修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ‘lianggzone’ <span class="keyword">and</span> <span class="keyword">password</span> = ‘’ <span class="keyword">or</span> ‘<span class="number">1</span>’=‘<span class="number">1</span>’</span><br></pre></td></tr></table></figure>

<p>甚至，以前的校园网，不严谨的，设置密码时本身加上drop table这种，都属于SQL注入。所以他的原理很简单，让本应该只有一句SQL的语句，通过狗尾续貂的方式，再加上一句，使得SQL傻乎乎的去执行了第二句恶心代码。</p>
<p>那么我们防御的目标也就很明确了</p>
<ul>
<li>客户端<ul>
<li>有效性检验。</li>
<li>限制字符串输入的长度。 </li>
</ul>
</li>
<li>服务端<ul>
<li>不用拼接SQL字符串。</li>
<li>使用预编译的PrepareStatement。</li>
<li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li>
</ul>
</li>
</ul>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><hr>
<p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。既然我可以在SQL语句上搞猫腻，那我下次在使用评论功能时，在里面写脚本呢？没错，这就是xss攻击了。听起来很蠢，但如果不佳防范他可是能把你内裤是什么颜色都扒个清楚。之后会提到，他和scrf一起攻击，拿到你的cookie信息后有多危险。</p>
<p>但是，他毕竟是显式的需要大摇大摆的写在http请求里的，要避免也并不复杂</p>
<ul>
<li><p>前端，服务端，同时需要字符串输入的长度限制。</p>
</li>
<li><p>前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。</p>
</li>
<li><p>防 XSS 的核心是必须对输入的数据做过滤处理。</p>
</li>
</ul>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><hr>
<p>重头戏，django自带避免csrf的中间件。跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。现在网站大抵都会提醒用户是否使用cookie就是因为害怕这个了。http在设计的时候本就是无状态的，既然是无状态那每次是否都需要做身份验证呢？如果把身份信息放置在一个地方，每次提交请求时直接从那里放进去，不就省了自己输入的麻烦？这也就是coockie的思想。</p>
<p>设想一下，下面的情况：</p>
<ol>
<li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p>
</li>
<li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p>
</li>
<li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p>
</li>
<li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p>
</li>
<li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
</li>
</ol>
<p>上面的这个例子，有几个点需要注意一下。首先csrf攻击并没有拿到你的coockie数据，只是利用了你现在还在登录的这个状态。第二他发送的恶意请求如果不加上反制措施是完全正常的。第三，但是他的确是从B网站而不是A网站发出去的。</p>
<p>针对上述特征，我们似乎可以对症下药了。</p>
<ul>
<li><p>尽量不要使用get去更新重要信息。get是在URL上明文传输的，而且对于穿过去的get请求的验证方式也没有post来的灵活。</p>
</li>
<li><p>送请求时，只有coockie里的信息是不够的。csrf最巧妙的地方就是他是一种愿者上钩的欺骗方式，一切的信息都是你coockie提供的，我只不过是提交了个请求而已。但是如果我们给提交请求额外设条件的话，csrf只能利用coockie，这样他伪造的请求就会因为条件不够而失败。比如：</p>
</li>
<li><p>在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。开始的时候我也是很奇怪，为什么加了一个token就行了。正常自己使用coockie时候也没看需要进行什么额外步骤啊。这是因为，除了cookie中的CSRF-Token外，请求体(POST)或者请求参数(GET)中也要有一个CSRF-Token，两者一样才是有效的。可是你csrf获取不到这个coockie里的token值啊，所以你伪造的请求里一定没有正确的token。（coockie里的token最好是httponly属性）</p>
</li>
<li><p>这个token不一定只可以放在请求里哦，还可以在HTTP头中定义属性验证。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token  值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest  请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
<li><p>还有验证 HTTP Referer 字段的方法，http refer可以鉴别请求的来源地址，如果出自非本站，那很可能就是伪造的请求了。</p>
</li>
</ul>
<h3 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h3><hr>
<p>dos是一台电脑，ddos是多台电脑。因为我们知道http是应用层协议，建立在传输层tcp协议的基础上。那tcp连接要建立的话需要三次握手啊，如果你请求却又不进行第三次握手，相当于放服务器鸽子，服务器负载空增加，甚至严重就宕机了。</p>
<p>说实话这个目前也没什么好办法，毕竟也是合理的游戏规则，要解决就多花钱吧。</p>
<ul>
<li>同时打开SYN半链接的数目</li>
<li>SYN半链接的Time out 时间</li>
<li>不必要的服务</li>
</ul>
<p>最后可能还有一些其他的，比如dns劫持，dns投毒，apr劫持啥的，这里就不细细讨论了啊，为啥呢？因为我想睡觉了。下次一定，下次一定。</p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（一）</title>
    <url>/simon-blog.github.io/2020/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="频率统计和贝叶斯统计"><a href="#频率统计和贝叶斯统计" class="headerlink" title="频率统计和贝叶斯统计"></a>频率统计和贝叶斯统计</h2><p>题外话，果然不管是西澳大学还是墨尔本大学的lecture都是一样的垃圾。始终不能理解为什么有人能听lecture听的津津有味。lecture和最后要做的毫无关系也算是澳洲大学的传统技艺了。</p>
<a id="more"></a>

<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><hr>
<p>在频率派估计的观点下，真实参数集<em>θ</em>是固定的但未知，我们使用作为数据集函数的随机变量<em>θ</em>作为点估计。频率派统计基于<em>θ</em>作所有的预测。</p>
<p>贝叶斯使用概率来反映知识状态的确定程度。数据集是直接能够观测到因而不是随机的。贝叶斯派认为真实<em>θ</em>是未知的或不确定的，因此以一个随机变量来表示。</p>
<h4 id="总体信息、样本信息和先验信息。"><a href="#总体信息、样本信息和先验信息。" class="headerlink" title="总体信息、样本信息和先验信息。"></a>总体信息、样本信息和先验信息。</h4><p>听起来一脸懵逼，首先理解三个概念：</p>
<p>数理统计学的任务是通过样本推断总体。把样本视为随机变量时，它有概率分布，称为总体分布。如果我们已经知道了总体的概率分布，那我们得到的这种信息就叫做总体信息。（比如投一次硬币是0-1分布）</p>
<p>另一种信息是样本信息，就是从总体中抽取的样本所提供的信息。我们希望通过观察样本的分布，从而对总体的分布或对总体的某些数字特征作出统计推断。（你实际投了几次，实际情况得出的概率）</p>
<p>第三种信息是先验信息（Prior Information），就是在抽样之前，根据经验和历史资料，得到的有关统计推断问题中未知参数的信息。（你投之前就知道硬币就两个面）</p>
<p>基于总体信息和样本信息进行统计推断的理论和方法，称为经典（古典）统计学，它的基本观点是：把样本看成是来自于有一定概率分布的总体，所研究的对象是这个总体而不局限于数据本身。（遇到问题不要怕，我先套个公式先，一定存在一个公式，能完美解释这个情况）</p>
<p>而基于总体信息、样本信息和先验信息进行统计推断的方法和理论，则称为贝叶斯统计学，它与经典统计学的主要区别在于是否利用先验信息。（老兄啊，这硬币反面有磨损的，怎么投都不会是概率0.5的）</p>
<p>在使用样本上也存在差别，贝叶斯统计学重视已出现的样本，对尚未出现的样本不予考虑。所以贝叶斯学派非常重视先验信息的收集、挖掘和加工，使之形成先验分布而参与到统计推断中，以提升统计推断的效果。（就是先入为主，解释了当前现象就行）</p>
<h4 id="主观立场"><a href="#主观立场" class="headerlink" title="主观立场"></a>主观立场</h4><p>主观概率以及先验分布的确定。贝叶斯学派提出了主观概率，把主观概率理解为主体对事件发生的概率的相信程度，即不同的人对同一事件的概率可以得到不同的结果。（他测得是这个模型到底有多可靠）</p>
<p>而频率学派认为一个事件的概率要由大量重复试验下的频率来解释，不应该因人而异，必须具有客观性，而先验分布是主观随意的产物，不可以接受。（通过大量规律，寻找客观存在只是还没被发现的规律）</p>
<p>涉及“频率解释”本身。许多事件是一次性的，在严格或大致相同条件下让这一个事件重复出现是不可能的。（分手了就给我爬开，这辈子都不会有下次一定了）</p>
<p>事前规定精度和可靠度不合理。频率学派基于概率的频率解释，其方法（点估计、区间估计和假设检验）的精度和可靠度，是在事前（抽样前）就定下的，称为“事前精度”和“事前可靠度”。而贝叶斯学派认为统计推断的精度和可靠度，应该与实际的样本值有关，应当采用“事后精度”和“事后可靠度”。</p>
<p>说白了，贝叶斯就比较粗暴，他基于一些事先的评判来做出概率的模型，然后检测这个模型的可靠程度。而old school的频率论就死守着概率推导的严谨性，就好象在和你说茴字有四种写法，在真的确定一个分布前，他做的一切都是0,甚至有的事情情况过于复杂，传统的推导是很难找到其中规律的。贝叶斯选择了像现实妥协。（我个人更喜欢贝叶斯的想法，在我看来频率论就像是连merge sort都写不出来的人在指责你A星算法选的启发式不够好一样）</p>
<h4 id="从对未知参数的认识上来理解"><a href="#从对未知参数的认识上来理解" class="headerlink" title="从对未知参数的认识上来理解"></a>从对未知参数的认识上来理解</h4><p>频率学派把未知参数θ看成一个未知的固定量，仅把样本看做随机变量，而贝叶斯学派把未知参数也看做是随机变量。终于绕回来了，现在在看这句话是不是又有了新的想法。</p>
<h3 id="先验分布、后验分布和共轭分布"><a href="#先验分布、后验分布和共轭分布" class="headerlink" title="先验分布、后验分布和共轭分布"></a>先验分布、后验分布和共轭分布</h3><hr>
<p>贝叶斯统计学与经典统计学的不同之处在于，贝叶斯统计学在统计推断时除了利用抽样信息外，还利用参数的先验信息。先验分布的确定有很大的主观性和随意性，当先验分布完全未知或部分未知时，如果人为给定的先验分布与实际情形偏离较大，那么贝叶斯解的性质就比较差。</p>
<h4 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a><strong>先验分布</strong></h4><p>参数空间Θ上的任一概率分布都称为先验分布（Prior Distribution）。</p>
<p>用π(θ)来表示随机变量θ的概率函数（当θ为连续型随机变量时，π(θ)表示θ的密度函数；当θ为离散型随机变量时，π(θi)表示概率p(θ=θi)，i=1,2,…,n）。</p>
<p>先验分布π(θ)是在抽样样本X之前对参数θ可能取值的认识，在获取样本之后，由于样本X中也包含了θ的信息，故人们对θ的认识发生了变化，于是对θ的取值进行调整，就得到了参数θ的后验分布π(θ|x)。</p>
<p>先验分布的两种重要类型是<strong>无信息先验分布</strong>和<strong>共轭先验分布</strong>。</p>
<h4 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a><strong>后验分布</strong></h4><p>在获得样本X后，θ的后验分布（Posterior Distribution）就是在给定X=x的条件下θ的条件分布，记为π(θ|x)。求后验分布用的是贝叶斯公式。</p>
<p><strong>1：连续型</strong></p>
<p>θ为连续型随机变量时，其后验分布的密度函数为：<br>$$<br>\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}<br>$$<br>其中，h(x, θ) = f(x|θ)π(θ) 是X和θ的联合密度，f(x|θ) 是样本的概率密度函数。而m(x)：<br>$$<br>m(x) =\int_{\theta}h(x,\theta)d\theta =\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)<br>$$<br><strong>2：离散型</strong></p>
<p>当θ是离散型随机变量时，先验分布可用先验分布列｛π(θi)，i=1,2,…,n｝来表示，这时的后验分布是如下离散形式：<br>$$<br>\pi(\theta_{i}|x) = \frac{f(x|\theta_i)\pi(\theta_i)}{\sum{f(x|\theta_i)\pi(\theta_i)}}<br>$$<br>那么后验分布可以看做是人们用总体信息和样本信息（统称为抽样信息）对先验分布作调整的结果，是总体信息、样本信息和先验信息的综合。</p>
<h4 id="似然函数与共轭分布"><a href="#似然函数与共轭分布" class="headerlink" title="似然函数与共轭分布"></a><strong>似然函数与共轭分布</strong></h4><p><strong>1：似然函数</strong></p>
<p>对于后验分布计算公式中的f(x|θ)，从不同的角度看有不同的含义：</p>
<p>① 概率密度函数：若参数θ已知，而x是未知变量，那么描述的是不同样本点的概率，叫做概率密度函数。</p>
<p>② 似然函数：若x是已经确定的，而参数θ是变量，那么描述的是对于不同的参数θ，某一个样本出现的概率，一般写作l(θ|x)，叫做参数θ的似然函数。</p>
<p>从上面已知，后验分布 = 样本的密度函数×先验分布/边缘分布，也可以看做：后验分布 = 似然函数×先验分布/边缘分布。</p>
<p><strong>2：共轭分布</strong></p>
<p>已知后验分布 = 似然函数×先验分布/边缘分布，那么如果后验分布与先验分布有相同的形式，比如都服从贝塔分布，那么就称似然函数和先验分布是共轭的，互为共轭分布，先验分布是似然函数的共轭先验分布。<br>$$<br>\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}<br>$$<br>如果计算出来的π(θ|x)和π(θ)有相同的分布类型，那么称f(x|θ)和π(θ)互为共轭分布，π(θ)是f(x|θ)的共轭先验分布。</p>
<p><strong>后验分布的简化计算</strong><br>$$<br>\pi(\theta|x) = \frac{h(x,\theta)}{m(x)}\propto f(x|\theta)\pi(\theta)<br>$$<br>符号∝表示“正比于”，即符号左边的式子和右边的式子只差了一个与参数θ无关的常数因子。<strong>π(θ|x) = 正则化因子 × {f(x|θ)的核} × {π(θ)的核}</strong></p>
<p>(我看到这里一头雾水？？？我有干什么来着？)</p>
<h3 id="最大似然估计和最大后验概率估计"><a href="#最大似然估计和最大后验概率估计" class="headerlink" title="最大似然估计和最大后验概率估计"></a>最大似然估计和最大后验概率估计</h3><hr>
<p>统计要解决的问题是，手头有一堆数据，要利用这堆数据去推测模型和参数，而最大似然估计和最大后验概率估计就是推断模型和参数的两种不同方法。</p>
<h4 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a><strong>最大似然估计</strong></h4><p>最大似然估计是求参数θ, 使似然函数p(X|θ)最大。<strong>频率学派</strong>采用最大似然估计来推断模型的参数。</p>
<p>最大似然估计的含义是根据已经采集到的样本，希望通过调整模型参数使得这些样本被选中的概率最大。</p>
<p>样本的似然函数为p(X|θ)，可以理解为已知样本集合X的情况下，所有样本点同时出现的概率，是关于参数θ的函数，因此最大似然估计就是要最大化似然函数。</p>
<p>最大似然估计的目标函数为：<br>$$<br>p(X|\theta) = \prod^{xn}<em>{x1}p(xi|\theta) = \sum^{xn}</em>{x1}logp(xi|\theta)<br>$$</p>
<h4 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a><strong>最大后验概率估计</strong></h4><p>最大后验概率估计则是想求参数θ，使p(x|θ)p(θ)，即后验概率最大。求得的θ不单让似然函数大，θ本身出现的先验概率也得大。贝叶斯学派采用最大后验概率估计来推断模型的参数。</p>
<p>最大后验概率估计的含义是基于对参数的一个先验假设，并根据已经收集到的样本，通过调整参数使得这些样本被选中的后验概率最大。模型参数本身满足某种分布，不再一味依赖数据样例。</p>
<p>如果以密度函数来进行计算，最大后验概率估计的目标函数就是：<br>$$<br>\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}<br>$$<br><strong>联系和区别</strong></p>
<p>最大似然估计比较依赖较大的数据量和大数定律，在样本量较少时，参数估计的结果容易出现较大偏差。</p>
<p>最大后验概率估计允许我们把先验知识加入到估计模型中，这在样本很少的时候是很有用的。但是随着样本量的增大，参数估计的结果主要受数据量的影响，先验假设的影响会越来越小。</p>
<p>如果参数θ服从于均匀分布U(0,1)时，有先验概率为p(θ)=1，此时最大似然估计和最大后验概率估计是等价的。</p>
<p>看不明白也没啥大不了的，只是记录一下实际公式，应用可以看相关链接</p>
<p>(相关链接：<a href="https://cloud.tencent.com/developer/article/1640085">贝叶斯学派与频率学派</a>,·<a href="https://zhuanlan.zhihu.com/p/48071601">MLE&amp;MAP</a>)</p>
<h2 id="决策理论-博弈论"><a href="#决策理论-博弈论" class="headerlink" title="决策理论(博弈论)"></a>决策理论(博弈论)</h2><p>决策论背后的核心思想是<strong>最小化期望损失</strong> 。定义清楚期望损失，问题就转变成最优化问题，带入优化器，就迎刃而解了。</p>
<table>
<thead>
<tr>
<th>#</th>
<th align="right">实际值 0</th>
<th align="right">实际值 1</th>
</tr>
</thead>
<tbody><tr>
<td>预测值 0</td>
<td align="right">00</td>
<td align="right">01</td>
</tr>
<tr>
<td>预测值 1</td>
<td align="right">10</td>
<td align="right">11</td>
</tr>
</tbody></table>
<p>(0 表示失败， 1表示成功; 01是最不能接受的结果，其次是10)</p>
<p>0-1损失：<br>$$<br>L(y,\hat{y}) = I(y\not=\hat{y})= {0 \ \ \ if\ y = \hat{y}\choose 1\ \ \ \ else}<br>$$<br>平方损失：<br>$$<br>L(y,\hat y) = (y- \hat y)^2<br>$$</p>
<h3 id="经验风险最小化"><a href="#经验风险最小化" class="headerlink" title="经验风险最小化"></a>经验风险最小化</h3><hr>
<p>上面我们提到了两种损失函数，根据机器学习的目标，损失函数值越小，模型就越好。由于模型的输入输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是：<br>$$<br>R_{exp}(f) = E_p[L(Y,\hat y)]= \int L(y,\hat{y})P(y,\hat y) d\hat y dy<br>$$<br>这是理论上的期望风险模型，但是联合分布究竟以何种形式我们是未知的，所以我们使用训练数据的平均损失作为近似值，也就是经验风险：<br>$$<br>R_{emp}(f) = \frac{1}{N}\sum^N_{i=1}L(y_i,\hat y_i)<br>$$<br>那么标题的经验风险最小化就很容易理解了，即经验风险最小的模型是最优的模型。(R_emp min)</p>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果。比如，<strong>极大似然估计</strong>（就是经验风险最小化的一个例子，<strong>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。</strong>(是古典学派的胜利啊)</p>
<h3 id="结构风险最小化"><a href="#结构风险最小化" class="headerlink" title="结构风险最小化"></a>结构风险最小化</h3><hr>
<p>结构风险最小化（structural minimization,  SRM）是为了防止过拟合提出的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。<br>$$<br>R_{srm}(f) = R_{emp}+\lambda J(f)<br>$$<br>J(f)是模型复杂度函数，入大于0是系数。</p>
<p>结构风险小需要经验风险和模型复杂度同时都小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</p>
<p>贝叶斯估计中的最大后验概率估计（maximum posterior probability  estimation,MAP）就是结构风险最小化的一个例子，当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。</p>
<p>相关链接：<a href="https://blog.csdn.net/pxhdky/article/details/83544932">经验风险最小化与结构风险最小化</a></p>
<h3 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h3><hr>
<p>可以看到我们在上面计算损失时，都是只用了训练数据本身，那很自然的想到，这种没有使用先验概率的想法是频率统计的风格。那贝叶斯决策，也就是在次基础上加上先验概率了。<br>$$<br>\lambda^{(i)}_j = \lambda(\omega_i|\omega_j)\ \ \ (i,j=1,2,…,c)<br>$$<br>表示将j类误判为i类的损失，c为类数。由λ构成一个c×c的损失矩阵，也即表示决策表。</p>
<p>最小风险贝叶斯决策的判决函数为：<br>$$<br>minR_i(x) = \sum^c_{j=1}\lambda_j^{(i)}P(w_j|x)<br>$$</p>
<h4 id="贝叶斯决策的一般过程"><a href="#贝叶斯决策的一般过程" class="headerlink" title="贝叶斯决策的一般过程"></a>贝叶斯决策的一般过程</h4><p>1）估计先验概率：①根据实际情况做经验估计；②根据样本分布的频率估计概率。</p>
<p>（2）计算类条件概率密度：①参数估计：类条件概率分布类型已知，参数未知，通过训练样本来估计（最大似然法、Bayes估计）；②非参数估计：不判断类条件概率分布类型，直接根据训练样本来估计（Parzen窗、kn-近邻法）。</p>
<p>（3）计算后验概率。</p>
<p>（4-1）若进行最小错误率决策，根据后验概率即可作出决策。</p>
<p>（4-2）若进行最小风险决策，使用上面公式</p>
<p>相关链接：<a href="https://www.cnblogs.com/hizhaolei/p/8196096.html">贝叶斯决策</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学校</tag>
      </tags>
  </entry>
</search>
