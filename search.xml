<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/simon-blog.github.io/2020/08/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>python元类和装饰器</title>
    <url>/simon-blog.github.io/2020/08/08/python%E5%85%83%E7%B1%BB%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h2><p>动态添加函数功能，相当于在原函数上套了一层皮，动态添加新的职责。比如Django，flask里的@session现在终于是弄明白那一块用户身份验证的原理了。（在原来的view函数上使用装饰者模式，如果http请求里包含了session的ID就允许render，从而实现一些页面对于用户的隐藏）</p>
<a id="more"></a>
<p>相关的身份验证代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(f)        # 这里的@开头的部分就是一个装饰器，虽然他不是重点，只是用来确保原函数属性不变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure>
<p>可能这样看并不明显，那么接下来两个例子就很好的说明了他的具体用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span>(<span class="params">a_func</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span>():</span></span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work before executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        a_func()</span><br><span class="line"> </span><br><span class="line">        print(<span class="string">&quot;I am doing some boring work after executing a_func()&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>a_new_decorator 这个函数以另一个函数为变量，a_function_requiring_decoration在使用装饰函数包裹他之后，他的输出就额外多出了两行。但是这并不是decorator的典型写法，下面才是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;I am the function which needs some decoration to &quot;</span></span><br><span class="line">          <span class="string">&quot;remove my foul smell&quot;</span>)</span><br><span class="line"> </span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure>
<p>使用@开始一个装饰器，非常的优雅。同时装饰器并不是只能这么笨重的使用，他也是函数，他也是对象。那么他就可以附加额外的参数，甚至你可以定义一个装饰器类。当然这里就不展开细讲了。详细可以左转</p>
<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python装饰器函数</a> </p>
<h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>可以创建类的类，听起来是不是很像工厂模式？虽然很像，但他可不只单单可以创建类那么简单，甚至可以修改已经创建好的类的属性。</p>
<p>正常的创建类的方式：</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass = type(<span class="string">&#x27;Myclass&#x27;</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>使用元类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListMeta</span>(<span class="params">type</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 用元类实现给类添加属性 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, attrs</span>):</span></span><br><span class="line">        attrs[<span class="string">&#x27;add&#x27;</span>] = <span class="keyword">lambda</span> self, value: self.append(value)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(mcs, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>(<span class="params">list, metaclass=ListMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">l = MyList()</span><br><span class="line">l.add(<span class="number">1</span>)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>
<p>你可能会奇怪，怎么写的这么别扭，还用了lamda函数，就往原来的类里面加了个add方法，那我用装饰器不就好了。U1S1,QS. 但是，元类绝对不是这么鸡肋的存在。我所了解的，Django，flask这些框架使用的ORM就是基于元类，对于model类的动态控制，来实现mysql语句的更新和管理使用到的数据。同时，元类还可以用于创建python里的单列模式。（但python所有东西都是对象，真的有必要单列吗）</p>
<h2 id="类的new和init"><a href="#类的new和init" class="headerlink" title="类的new和init"></a>类的<strong>new</strong>和<strong>init</strong></h2><p>惊了，markdown打不出来<strong>new</strong>方法吗，会变成加粗字体。嘛，反正你们也知道我在说什么吧。</p>
<p>一般在python里<strong>new</strong>方法创建实例，<strong>init</strong>负责初始化一个实例。<strong>new</strong>方法返回创建的对象，而<strong>init</strong>方法禁止返回值(必须返回None)。有一个简单的原则来判断什么使用使用<strong>init</strong>和<strong>new</strong>：</p>
<ul>
<li>如果需要修改类的属性，使用元类的<strong>new</strong>方法</li>
<li>如果只是做一些类属性检查的工作，使用元类的<strong>init</strong>方法</li>
<li>如果 new 方法不返回对象， 则不会调用 init 函数</li>
</ul>
<p>我能想到的这部分知识就先整理成这样吧，如果想起来还会加的。最后放一下参考的文章</p>
<p><a href="https://blog.csdn.net/kisslotus/article/details/83793781#4___new____init___132">Python 高级编程之元类和装饰器</a> </p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>常见网络攻击</title>
    <url>/simon-blog.github.io/2020/08/08/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前总结了网络的一些知识点，大概可以用网络的4层协议模型概括。虽然前博客的数据没了，但我会从新写一遍。今天就先来看一下之前没提到的网络安全这一块吧，也算是给自己查漏补缺了。<br><a id="more"></a></p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><hr>
<p>这个相信大家肯定都有所耳闻，以前我天真的以为就是在url的后面加上<code>or 1=1</code>显然并不是这样。在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。比如你输入用户名密码登录时，你将请求修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ‘lianggzone’ <span class="keyword">and</span> <span class="keyword">password</span> = ‘’ <span class="keyword">or</span> ‘<span class="number">1</span>’=‘<span class="number">1</span>’</span><br></pre></td></tr></table></figure>
<p>甚至，以前的校园网，不严谨的，设置密码时本身加上drop table这种，都属于SQL注入。所以他的原理很简单，让本应该只有一句SQL的语句，通过狗尾续貂的方式，再加上一句，使得SQL傻乎乎的去执行了第二句恶心代码。</p>
<p>那么我们防御的目标也就很明确了</p>
<ul>
<li>客户端<ul>
<li>有效性检验。</li>
<li>限制字符串输入的长度。 </li>
</ul>
</li>
<li>服务端<ul>
<li>不用拼接SQL字符串。</li>
<li>使用预编译的PrepareStatement。</li>
<li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li>
</ul>
</li>
</ul>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><hr>
<p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。既然我可以在SQL语句上搞猫腻，那我下次在使用评论功能时，在里面写脚本呢？没错，这就是xss攻击了。听起来很蠢，但如果不佳防范他可是能把你内裤是什么颜色都扒个清楚。之后会提到，他和scrf一起攻击，拿到你的cookie信息后有多危险。</p>
<p>但是，他毕竟是显式的需要大摇大摆的写在http请求里的，要避免也并不复杂</p>
<ul>
<li><p>前端，服务端，同时需要字符串输入的长度限制。</p>
</li>
<li><p>前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。</p>
</li>
<li><p>防 XSS 的核心是必须对输入的数据做过滤处理。</p>
</li>
</ul>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><hr>
<p>重头戏，django自带避免csrf的中间件。跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。现在网站大抵都会提醒用户是否使用cookie就是因为害怕这个了。http在设计的时候本就是无状态的，既然是无状态那每次是否都需要做身份验证呢？如果把身份信息放置在一个地方，每次提交请求时直接从那里放进去，不就省了自己输入的麻烦？这也就是coockie的思想。</p>
<p>设想一下，下面的情况：</p>
<ol>
<li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p>
</li>
<li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p>
</li>
<li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p>
</li>
<li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p>
</li>
<li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
</li>
</ol>
<p>上面的这个例子，有几个点需要注意一下。首先csrf攻击并没有拿到你的coockie数据，只是利用了你现在还在登录的这个状态。第二他发送的恶意请求如果不加上反制措施是完全正常的。第三，但是他的确是从B网站而不是A网站发出去的。</p>
<p>针对上述特征，我们似乎可以对症下药了。</p>
<ul>
<li><p>尽量不要使用get去更新重要信息。get是在URL上明文传输的，而且对于穿过去的get请求的验证方式也没有post来的灵活。</p>
</li>
<li><p>送请求时，只有coockie里的信息是不够的。csrf最巧妙的地方就是他是一种愿者上钩的欺骗方式，一切的信息都是你coockie提供的，我只不过是提交了个请求而已。但是如果我们给提交请求额外设条件的话，csrf只能利用coockie，这样他伪造的请求就会因为条件不够而失败。比如：</p>
</li>
<li><p>在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。开始的时候我也是很奇怪，为什么加了一个token就行了。正常自己使用coockie时候也没看需要进行什么额外步骤啊。这是因为，除了cookie中的CSRF-Token外，请求体(POST)或者请求参数(GET)中也要有一个CSRF-Token，两者一样才是有效的。可是你csrf获取不到这个coockie里的token值啊，所以你伪造的请求里一定没有正确的token。（coockie里的token最好是httponly属性）</p>
</li>
<li><p>这个token不一定只可以放在请求里哦，还可以在HTTP头中定义属性验证。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token  值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest  请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
</li>
<li><p>还有验证 HTTP Referer 字段的方法，http refer可以鉴别请求的来源地址，如果出自非本站，那很可能就是伪造的请求了。</p>
</li>
</ul>
<h3 id="DDos-攻击"><a href="#DDos-攻击" class="headerlink" title="DDos 攻击"></a>DDos 攻击</h3><hr>
<p>dos是一台电脑，ddos是多台电脑。因为我们知道http是应用层协议，建立在传输层tcp协议的基础上。那tcp连接要建立的话需要三次握手啊，如果你请求却又不进行第三次握手，相当于放服务器鸽子，服务器负载空增加，甚至严重就宕机了。</p>
<p>说实话这个目前也没什么好办法，毕竟也是合理的游戏规则，要解决就多花钱吧。</p>
<ul>
<li>同时打开SYN半链接的数目</li>
<li>SYN半链接的Time out 时间</li>
<li>不必要的服务</li>
</ul>
<p>最后可能还有一些其他的，比如dns劫持，dns投毒，apr劫持啥的，这里就不细细讨论了啊，为啥呢？因为我想睡觉了。下次一定，下次一定。</p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记（一）</title>
    <url>/simon-blog.github.io/2020/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="频率统计和贝叶斯统计"><a href="#频率统计和贝叶斯统计" class="headerlink" title="频率统计和贝叶斯统计"></a>频率统计和贝叶斯统计</h2><p>题外话，果然不管是西澳大学还是墨尔本大学的lecture都是一样的垃圾。始终不能理解为什么有人能听lecture听的津津有味。lecture和最后要做的毫无关系也算是澳洲大学的传统技艺了。</p>
<a id="more"></a>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><hr>
<p>在频率派估计的观点下，真实参数集<em>θ</em>是固定的但未知，我们使用作为数据集函数的随机变量<em>θ</em>作为点估计。频率派统计基于<em>θ</em>作所有的预测。</p>
<p>贝叶斯使用概率来反映知识状态的确定程度。数据集是直接能够观测到因而不是随机的。贝叶斯派认为真实<em>θ</em>是未知的或不确定的，因此以一个随机变量来表示。</p>
<h4 id="总体信息、样本信息和先验信息。"><a href="#总体信息、样本信息和先验信息。" class="headerlink" title="总体信息、样本信息和先验信息。"></a>总体信息、样本信息和先验信息。</h4><p>听起来一脸懵逼，首先理解三个概念：</p>
<p>数理统计学的任务是通过样本推断总体。把样本视为随机变量时，它有概率分布，称为总体分布。如果我们已经知道了总体的概率分布，那我们得到的这种信息就叫做总体信息。（比如投一次硬币是0-1分布）</p>
<p>另一种信息是样本信息，就是从总体中抽取的样本所提供的信息。我们希望通过观察样本的分布，从而对总体的分布或对总体的某些数字特征作出统计推断。（你实际投了几次，实际情况得出的概率）</p>
<p>第三种信息是先验信息（Prior Information），就是在抽样之前，根据经验和历史资料，得到的有关统计推断问题中未知参数的信息。（你投之前就知道硬币就两个面）</p>
<p>基于总体信息和样本信息进行统计推断的理论和方法，称为经典（古典）统计学，它的基本观点是：把样本看成是来自于有一定概率分布的总体，所研究的对象是这个总体而不局限于数据本身。（遇到问题不要怕，我先套个公式先，一定存在一个公式，能完美解释这个情况）</p>
<p>而基于总体信息、样本信息和先验信息进行统计推断的方法和理论，则称为贝叶斯统计学，它与经典统计学的主要区别在于是否利用先验信息。（老兄啊，这硬币反面有磨损的，怎么投都不会是概率0.5的）</p>
<p>在使用样本上也存在差别，贝叶斯统计学重视已出现的样本，对尚未出现的样本不予考虑。所以贝叶斯学派非常重视先验信息的收集、挖掘和加工，使之形成先验分布而参与到统计推断中，以提升统计推断的效果。（就是先入为主，解释了当前现象就行）</p>
<h4 id="主观立场"><a href="#主观立场" class="headerlink" title="主观立场"></a>主观立场</h4><p>主观概率以及先验分布的确定。贝叶斯学派提出了主观概率，把主观概率理解为主体对事件发生的概率的相信程度，即不同的人对同一事件的概率可以得到不同的结果。（他测得是这个模型到底有多可靠）</p>
<p>而频率学派认为一个事件的概率要由大量重复试验下的频率来解释，不应该因人而异，必须具有客观性，而先验分布是主观随意的产物，不可以接受。（通过大量规律，寻找客观存在只是还没被发现的规律）</p>
<p>涉及“频率解释”本身。许多事件是一次性的，在严格或大致相同条件下让这一个事件重复出现是不可能的。（分手了就给我爬开，这辈子都不会有下次一定了）</p>
<p>事前规定精度和可靠度不合理。频率学派基于概率的频率解释，其方法（点估计、区间估计和假设检验）的精度和可靠度，是在事前（抽样前）就定下的，称为“事前精度”和“事前可靠度”。而贝叶斯学派认为统计推断的精度和可靠度，应该与实际的样本值有关，应当采用“事后精度”和“事后可靠度”。</p>
<p>说白了，贝叶斯就比较粗暴，他基于一些事先的评判来做出概率的模型，然后检测这个模型的可靠程度。而old school的频率论就死守着概率推导的严谨性，就好象在和你说茴字有四种写法，在真的确定一个分布前，他做的一切都是0,甚至有的事情情况过于复杂，传统的推导是很难找到其中规律的。贝叶斯选择了像现实妥协。（我个人更喜欢贝叶斯的想法，在我看来频率论就像是连merge sort都写不出来的人在指责你A星算法选的启发式不够好一样）</p>
<h4 id="从对未知参数的认识上来理解"><a href="#从对未知参数的认识上来理解" class="headerlink" title="从对未知参数的认识上来理解"></a>从对未知参数的认识上来理解</h4><p>频率学派把未知参数θ看成一个未知的固定量，仅把样本看做随机变量，而贝叶斯学派把未知参数也看做是随机变量。终于绕回来了，现在在看这句话是不是又有了新的想法。</p>
<h3 id="先验分布、后验分布和共轭分布"><a href="#先验分布、后验分布和共轭分布" class="headerlink" title="先验分布、后验分布和共轭分布"></a>先验分布、后验分布和共轭分布</h3><hr>
<p>贝叶斯统计学与经典统计学的不同之处在于，贝叶斯统计学在统计推断时除了利用抽样信息外，还利用参数的先验信息。先验分布的确定有很大的主观性和随意性，当先验分布完全未知或部分未知时，如果人为给定的先验分布与实际情形偏离较大，那么贝叶斯解的性质就比较差。</p>
<h4 id="先验分布"><a href="#先验分布" class="headerlink" title="先验分布"></a><strong>先验分布</strong></h4><p>参数空间Θ上的任一概率分布都称为先验分布（Prior Distribution）。</p>
<p>用π(θ)来表示随机变量θ的概率函数（当θ为连续型随机变量时，π(θ)表示θ的密度函数；当θ为离散型随机变量时，π(θi)表示概率p(θ=θi)，i=1,2,…,n）。</p>
<p>先验分布π(θ)是在抽样样本X之前对参数θ可能取值的认识，在获取样本之后，由于样本X中也包含了θ的信息，故人们对θ的认识发生了变化，于是对θ的取值进行调整，就得到了参数θ的后验分布π(θ|x)。</p>
<p>先验分布的两种重要类型是<strong>无信息先验分布</strong>和<strong>共轭先验分布</strong>。</p>
<h4 id="后验分布"><a href="#后验分布" class="headerlink" title="后验分布"></a><strong>后验分布</strong></h4><p>在获得样本X后，θ的后验分布（Posterior Distribution）就是在给定X=x的条件下θ的条件分布，记为π(θ|x)。求后验分布用的是贝叶斯公式。</p>
<p><strong>1：连续型</strong></p>
<p>θ为连续型随机变量时，其后验分布的密度函数为：</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p>其中，h(x, θ) = f(x|θ)π(θ) 是X和θ的联合密度，f(x|θ) 是样本的概率密度函数。而m(x)：</p>
<script type="math/tex; mode=display">
m(x) =\int_{\theta}h(x,\theta)d\theta =\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)</script><p><strong>2：离散型</strong></p>
<p>当θ是离散型随机变量时，先验分布可用先验分布列｛π(θi)，i=1,2,…,n｝来表示，这时的后验分布是如下离散形式：</p>
<script type="math/tex; mode=display">
\pi(\theta_{i}|x) = \frac{f(x|\theta_i)\pi(\theta_i)}{\sum{f(x|\theta_i)\pi(\theta_i)}}</script><p>那么后验分布可以看做是人们用总体信息和样本信息（统称为抽样信息）对先验分布作调整的结果，是总体信息、样本信息和先验信息的综合。</p>
<h4 id="似然函数与共轭分布"><a href="#似然函数与共轭分布" class="headerlink" title="似然函数与共轭分布"></a><strong>似然函数与共轭分布</strong></h4><p><strong>1：似然函数</strong></p>
<p>对于后验分布计算公式中的f(x|θ)，从不同的角度看有不同的含义：</p>
<p>① 概率密度函数：若参数θ已知，而x是未知变量，那么描述的是不同样本点的概率，叫做概率密度函数。</p>
<p>② 似然函数：若x是已经确定的，而参数θ是变量，那么描述的是对于不同的参数θ，某一个样本出现的概率，一般写作l(θ|x)，叫做参数θ的似然函数。</p>
<p>从上面已知，后验分布 = 样本的密度函数×先验分布/边缘分布，也可以看做：后验分布 = 似然函数×先验分布/边缘分布。</p>
<p><strong>2：共轭分布</strong></p>
<p>已知后验分布 = 似然函数×先验分布/边缘分布，那么如果后验分布与先验分布有相同的形式，比如都服从贝塔分布，那么就称似然函数和先验分布是共轭的，互为共轭分布，先验分布是似然函数的共轭先验分布。</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p>如果计算出来的π(θ|x)和π(θ)有相同的分布类型，那么称f(x|θ)和π(θ)互为共轭分布，π(θ)是f(x|θ)的共轭先验分布。</p>
<p><strong>后验分布的简化计算</strong></p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)}\propto f(x|\theta)\pi(\theta)</script><p>符号∝表示“正比于”，即符号左边的式子和右边的式子只差了一个与参数θ无关的常数因子。<strong>π(θ|x) = 正则化因子 × {f(x|θ)的核} × {π(θ)的核}</strong></p>
<p>(我看到这里一头雾水？？？我有干什么来着？)</p>
<h3 id="最大似然估计和最大后验概率估计"><a href="#最大似然估计和最大后验概率估计" class="headerlink" title="最大似然估计和最大后验概率估计"></a>最大似然估计和最大后验概率估计</h3><hr>
<p>统计要解决的问题是，手头有一堆数据，要利用这堆数据去推测模型和参数，而最大似然估计和最大后验概率估计就是推断模型和参数的两种不同方法。</p>
<h4 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a><strong>最大似然估计</strong></h4><p>最大似然估计是求参数θ, 使似然函数p(X|θ)最大。<strong>频率学派</strong>采用最大似然估计来推断模型的参数。</p>
<p>最大似然估计的含义是根据已经采集到的样本，希望通过调整模型参数使得这些样本被选中的概率最大。</p>
<p>样本的似然函数为p(X|θ)，可以理解为已知样本集合X的情况下，所有样本点同时出现的概率，是关于参数θ的函数，因此最大似然估计就是要最大化似然函数。</p>
<p>最大似然估计的目标函数为：</p>
<script type="math/tex; mode=display">
p(X|\theta) = \prod^{xn}_{x1}p(xi|\theta) = \sum^{xn}_{x1}logp(xi|\theta)</script><h4 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a><strong>最大后验概率估计</strong></h4><p>最大后验概率估计则是想求参数θ，使p(x|θ)p(θ)，即后验概率最大。求得的θ不单让似然函数大，θ本身出现的先验概率也得大。贝叶斯学派采用最大后验概率估计来推断模型的参数。</p>
<p>最大后验概率估计的含义是基于对参数的一个先验假设，并根据已经收集到的样本，通过调整参数使得这些样本被选中的后验概率最大。模型参数本身满足某种分布，不再一味依赖数据样例。</p>
<p>如果以密度函数来进行计算，最大后验概率估计的目标函数就是：</p>
<script type="math/tex; mode=display">
\pi(\theta|x) = \frac{h(x,\theta)}{m(x)} = \frac{f(x|\theta)\pi(\theta)}{\int_{\theta}f(x|\theta)\pi(\theta)d(\theta)}</script><p><strong>联系和区别</strong></p>
<p>最大似然估计比较依赖较大的数据量和大数定律，在样本量较少时，参数估计的结果容易出现较大偏差。</p>
<p>最大后验概率估计允许我们把先验知识加入到估计模型中，这在样本很少的时候是很有用的。但是随着样本量的增大，参数估计的结果主要受数据量的影响，先验假设的影响会越来越小。</p>
<p>如果参数θ服从于均匀分布U(0,1)时，有先验概率为p(θ)=1，此时最大似然估计和最大后验概率估计是等价的。</p>
<p>看不明白也没啥大不了的，只是记录一下实际公式，应用可以看相关链接</p>
<p>(相关链接：<a href="https://cloud.tencent.com/developer/article/1640085">贝叶斯学派与频率学派</a>,·<a href="https://zhuanlan.zhihu.com/p/48071601">MLE&amp;MAP</a>)</p>
<h2 id="决策理论-博弈论"><a href="#决策理论-博弈论" class="headerlink" title="决策理论(博弈论)"></a>决策理论(博弈论)</h2><p>决策论背后的核心思想是<strong>最小化期望损失</strong> 。定义清楚期望损失，问题就转变成最优化问题，带入优化器，就迎刃而解了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>#</th>
<th style="text-align:right">实际值 0</th>
<th style="text-align:right">实际值 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>预测值 0</td>
<td style="text-align:right">00</td>
<td style="text-align:right">01</td>
</tr>
<tr>
<td>预测值 1</td>
<td style="text-align:right">10</td>
<td style="text-align:right">11</td>
</tr>
</tbody>
</table>
</div>
<p>(0 表示失败， 1表示成功; 01是最不能接受的结果，其次是10)</p>
<p>0-1损失：</p>
<script type="math/tex; mode=display">
L(y,\hat{y}) = I(y\not=\hat{y})= {0 \ \ \ if\ y = \hat{y}\choose 1\ \ \ \ else}</script><p>平方损失：</p>
<script type="math/tex; mode=display">
L(y,\hat y) = (y- \hat y)^2</script><h3 id="经验风险最小化"><a href="#经验风险最小化" class="headerlink" title="经验风险最小化"></a>经验风险最小化</h3><hr>
<p>上面我们提到了两种损失函数，根据机器学习的目标，损失函数值越小，模型就越好。由于模型的输入输出(X,Y)是随机变量，遵循联合分布P(X,Y)，所以损失函数的期望是：</p>
<script type="math/tex; mode=display">
R_{exp}(f) = E_p[L(Y,\hat y)]= \int L(y,\hat{y})P(y,\hat y) d\hat y dy</script><p>这是理论上的期望风险模型，但是联合分布究竟以何种形式我们是未知的，所以我们使用训练数据的平均损失作为近似值，也就是经验风险：</p>
<script type="math/tex; mode=display">
R_{emp}(f) = \frac{1}{N}\sum^N_{i=1}L(y_i,\hat y_i)</script><p>那么标题的经验风险最小化就很容易理解了，即经验风险最小的模型是最优的模型。(R_emp min)</p>
<p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果。比如，<strong>极大似然估计</strong>（就是经验风险最小化的一个例子，<strong>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。</strong>(是古典学派的胜利啊)</p>
<h3 id="结构风险最小化"><a href="#结构风险最小化" class="headerlink" title="结构风险最小化"></a>结构风险最小化</h3><hr>
<p>结构风险最小化（structural minimization,  SRM）是为了防止过拟合提出的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）。</p>
<script type="math/tex; mode=display">
R_{srm}(f) = R_{emp}+\lambda J(f)</script><p>J(f)是模型复杂度函数，入大于0是系数。</p>
<p>结构风险小需要经验风险和模型复杂度同时都小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。</p>
<p>贝叶斯估计中的最大后验概率估计（maximum posterior probability  estimation,MAP）就是结构风险最小化的一个例子，当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。</p>
<p>相关链接：<a href="https://blog.csdn.net/pxhdky/article/details/83544932">经验风险最小化与结构风险最小化</a></p>
<h3 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h3><hr>
<p>可以看到我们在上面计算损失时，都是只用了训练数据本身，那很自然的想到，这种没有使用先验概率的想法是频率统计的风格。那贝叶斯决策，也就是在次基础上加上先验概率了。</p>
<script type="math/tex; mode=display">
\lambda^{(i)}_j = \lambda(\omega_i|\omega_j)\ \ \ (i,j=1,2,...,c)</script><p>表示将j类误判为i类的损失，c为类数。由λ构成一个c×c的损失矩阵，也即表示决策表。</p>
<p>最小风险贝叶斯决策的判决函数为：</p>
<script type="math/tex; mode=display">
minR_i(x) = \sum^c_{j=1}\lambda_j^{(i)}P(w_j|x)</script><h4 id="贝叶斯决策的一般过程"><a href="#贝叶斯决策的一般过程" class="headerlink" title="贝叶斯决策的一般过程"></a>贝叶斯决策的一般过程</h4><p>1）估计先验概率：①根据实际情况做经验估计；②根据样本分布的频率估计概率。</p>
<p>（2）计算类条件概率密度：①参数估计：类条件概率分布类型已知，参数未知，通过训练样本来估计（最大似然法、Bayes估计）；②非参数估计：不判断类条件概率分布类型，直接根据训练样本来估计（Parzen窗、kn-近邻法）。</p>
<p>（3）计算后验概率。</p>
<p>（4-1）若进行最小错误率决策，根据后验概率即可作出决策。</p>
<p>（4-2）若进行最小风险决策，使用上面公式</p>
<p>相关链接：<a href="https://www.cnblogs.com/hizhaolei/p/8196096.html">贝叶斯决策</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>学校</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL知识整理</title>
    <url>/simon-blog.github.io/2020/08/14/MySQL%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>问数据库的东西肯定问sql的，你说你会redics，你会nosql。好的，项目用过吗，请开始你的表演。还是老老实实和他谈关系型数据库吧。这其中一般时间都在问你索引，不想被面试官怼穿就老老实实复习吧。</p>
<a id="more"></a>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>如何查看某个语法</p>
<p>在query语句前面加？</p>
<p>值得注意的是需要和在query语句前加explain区分，后面会提到explain，简单说explain是用来检查语句执行效率的，主要看使用索引的效率。</p>
</li>
<li><p>MySQL储存引擎</p>
<p>MYISAM，Innodb，memory，merge，csv，…其他我也没听过了</p>
<p>常用的就两种，最多加一个memory</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>MYIsAM</th>
<th style="text-align:left">Innodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件</td>
<td>每个MyISAM在磁盘上存储成三个文件。第一个 文件的名字以表的名字开始，扩展名指出文件类型。<br/>.frm文件存储表定义。<br/>数据文件的扩 展名为.MYD (MYData)。<br/>索引文件的扩 展名是.MYI (MYIndex)。<br/> 因为使用的是非簇集索引</td>
<td style="text-align:left">基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的 大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td>事务处理</td>
<td>MyISAM类型的表强调的是性能，其执行数 度比InnoDB类型更快，但是不提供事务支持 <br/> 如果执行大量的SELECT，MyISAM是更好的选择。</td>
<td style="text-align:left">InnoDB提供事务支持事务，外部键等高级 数据库功能.如果在应用中执行大量insert和update操作，应该选择InnoDB。清空整个表时，InnoDB是一行一行的删除，效率非常慢。</td>
</tr>
<tr>
<td>锁</td>
<td>表锁</td>
<td style="text-align:left">提供行锁(locking on row level)，提供与 <a href="http://www.ha97.com/category/database/oracle-database">Oracle</a> 类型一致的不加锁读取(non-locking read in<br/>SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执 行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”</td>
</tr>
<tr>
<td>表的行数</td>
<td>MyISAM只要简单的读出保存好的行数即可。</td>
<td style="text-align:left">InnoDB需要扫描一遍整个表来计算有多少行</td>
</tr>
</tbody>
</table>
</div>
<p>   基本的差别为：</p>
<p>   MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持已经外部键等高级数据库功能。</p>
<p>   MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。MyISAM缓存在内存的是索引，不是数据。而InnoDB缓存在内存的是数据，相对来说，服务器内存越大，InnoDB发挥的优势越大。</p>
<p>   Innodb是事务安全的。AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动Commit，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。</p>
<ol>
<li><p>选择合适的数据类型</p>
<ol>
<li>MyISAM 数据存储引擎和数据列 MyISAM数据表，最好使用固定长度的数据列代替可变长度的数据列。</li>
<li>MEMORY存储引擎和数据列 MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。</li>
<li>InnoDB 存储引擎和数据列 建议使用 VARCHAR类型  对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列(所有数据行 都使用指向数据列值的头指针)  ，因此在本质上，使用固定长度的CHAR列不一定比使 用可变长度VARCHAR列简单。 因而， 主要的性能因素是数据行使用的存储总量。 由于  CHAR 平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总 量和磁盘I/O是比较好的。</li>
</ol>
</li>
<li><p>ID自增不连续</p>
<p>唯一键冲突是导致自增主键id不连续的第一种原因</p>
<p>事务回滚是导致自增主键id不连续的第二种原因</p>
<p>批量申请自增id的策略是导致自增主键id不连续的第三种原因</p>
<p>解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table name auto_increment &#x3D; 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3NF</p>
<ul>
<li>1NF 指的是数据库表中的任何属性都具有原子性的，不可再分解</li>
<li>2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性</li>
<li>3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余</li>
</ul>
</li>
<li><p>事务4个特性</p>
<ul>
<li><strong>原子性 Atomicity：</strong>一个事务中的所有操作，要么全部完成，要么全部不完成，最小的执行单位。</li>
<li><strong>一致性 Consistency：</strong>事务执行前后，都处于一致性状态。</li>
<li><strong>隔离性 Isolation：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>
<li><strong>持久性 Durability：</strong>事务执行完成后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</li>
<li><p>事务的隔离等级</p>
<ul>
<li>READ_UNCOMMITTED 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。</li>
<li>READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题</li>
<li>REPEATABLE_READ 保证一个事务相同条件下前后两次获取的数据是一致的 （注意是 一个事务，可以理解为事务间的数据互不影响）解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。</li>
<li>SERIALIZABLE 事务串行执行，解决了脏读、不可重复读、幻读。但效率很差，所以实际中一般不用。</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li><p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p>
</li>
<li><p>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p>
</li>
<li><p>环路等待条件：在发生死锁时，必然存在一个进程—资源的环形链。</p>
<p>怎么解决：</p>
<ul>
<li>设置超时时间。超时后自动释放。</li>
<li>发起死锁检测，主动回滚其中一条事务，让其他事务继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>创建用户，授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL删除方式</p>
<ul>
<li>delete : 仅删除表数据，支持条件过滤，支持回滚。记录日志。因此比较慢。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>truncate: 仅删除所有数据，不支持条件过滤，不支持回滚。不记录日志，效率高于delete。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>drop:删除表数据同时删除表结构。将表所占的空间都释放掉。删除效率最高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MVVC</p>
<p>MVCC 全称是多版本并发控制系统，InnoDB 的 MVCC  是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version  number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
</li>
<li><p>MySQL使用流程</p>
<p>客户端连接数据库，验证身份。</p>
<p>获取当前用户权限。</p>
<p>当你查询时，会先去缓存看看，如果有返回。</p>
<p>如果没有，分析器对sql做词法分析。</p>
<p>优化器对sql进行“它认为比较好的优化”。</p>
<p>执行器负责具体执行sql语句。</p>
<p>最后把数据返回给客户端。</p>
</li>
<li><p>视图</p>
<p>视图(View)是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并 不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时 动态生成的。</p>
<p>视图相对于普通的表的优势主要包括以下几项。</p>
<ul>
<li>简单:使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件， 对用户来说已经是过滤好的复合条件的结果集。</li>
<li>安全:使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能 限制到某个行某个列，但是通过视图就可以简单的实现。</li>
<li>数据独立:一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加 列对视图没有影响;源表修改列名，则可以通过修改视图来解决，不会造成对访问 者的影响。</li>
</ul>
</li>
<li><p><strong>Explain的用法</strong></p>
</li>
</ol>
<pre><code>| column          | meaning                |
| --------------- | ---------------------- |
| id              | 查询序号               |
| **select_type** | join类型               |
| table           | 表名                   |
| partitions      | 匹配的分区             |
| **type**        | 查询类型               |
| possible_keys   | 可能选择的索引         |
| key             | 实际选择的索引         |
| key_len         | 索引长度               |
| ref             | 与索引比较的列         |
| rows            | 要检查的行数（估算值） |
| filtered        | 查询条件过滤行数百分比 |
| Extra           | extra                  |
</code></pre><ol>
<li><p>select_type参数</p>
<p><img src="https://s1.ax1x.com/2020/08/14/die76J.jpg" alt="die76J.jpg"></p>
</li>
<li><p>type参数</p>
<p>这是<strong>最重要的字段之一</strong>，显示查询使用了何种类型。从最好到最差的连接类型依次为：</p>
<blockquote>
<p>system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL</p>
</blockquote>
<p>1、system</p>
<p>表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p>
<p>2、const</p>
<p>最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描</p>
<p>3、eq_ref</p>
<p>多表join时，对于来自前面表的每一行，在当前表中只能找到一行。这可能是除了system和const之外最好的类型。当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型。</p>
<p>eq_ref可用于使用’=’操作符作比较的索引列。比较的值可以是常量，也可以是使用在此表之前读取的表的列的表达式。</p>
<blockquote>
<p>相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。 eq_ref只能找到一行，而ref能找到多行。</p>
</blockquote>
<p>4、ref</p>
<p>对于来自前面表的每一行，在此表的索引中可以匹配到多行。若联接只用到索引的最左前缀或索引不是主键或唯一索引时，使用ref类型（也就是说，此联接能够匹配多行记录）。</p>
<p>ref可用于使用’=’或’&lt;=&gt;’操作符作比较的索引列。</p>
<p>5、 fulltext</p>
<p>使用全文索引的时候是这个类型。要注意，<strong>全文索引的优先级很高</strong>，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
<p>6、ref_or_null</p>
<p>跟ref类型类似，只是增加了null值的比较。实际用的不多。</p>
<p>7、index_merge</p>
<p>表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如range</p>
<p>8、unique_subquery</p>
<p>用于where中的in形式子查询，子查询返回不重复值唯一值，可以完全替换子查询，效率更高。 该类型替换了下面形式的IN子查询的ref：  value IN (SELECT primary_key FROM single_table WHERE some_expr)</p>
<p>9、index_subquery</p>
<p>该联接类型类似于unique_subquery。适用于非唯一索引，可以返回重复值。</p>
<p>10、range</p>
<p>索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。</p>
<p>11、index</p>
<p>索引全表扫描，把索引从头到尾扫一遍。这里包含两种情况：  一种是查询使用了覆盖索引，那么它只需要扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在extra中显示Using index，反之，如果在索引上进行全表扫描，没有Using index的提示。</p>
<p>12、all</p>
<p>全表扫描，性能最差。</p>
</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>关于索引的部分请参考下一篇文章，都写在一起实在有点多啊。</p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引知识</title>
    <url>/simon-blog.github.io/2020/08/14/MySQL%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>书说上文，我们讲完了常见mysql问题，接下来我们来谈一谈他的索引。甚至你不去了解上一章的常见问题，你也要看完这一章的索引。对于数据库来说索引这样一个优秀的储存结构可以说是尤为重要。</p>
<a id="more"></a>
<ol>
<li><p>创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);</span><br><span class="line">或者</span><br><span class="line">CREATE INDEX index_name ON my_table(column_name);</span><br></pre></td></tr></table></figure>
<p>索引本身也要占空间，也可以把索引本身看作一张表</p>
<p>创建索引时需要锁表，注意是表锁。索引创建时本身也要全表搜索？</p>
</li>
<li><p>索引用法</p>
<p>具体查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE column_1&#x3D;column_2;(为column_1建立了索引)</span><br><span class="line"></span><br><span class="line">或者模糊查询</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</span><br><span class="line"></span><br><span class="line">如果要表示在字符串中既有A又有B，那么查询语句为：</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;A%&#39; AND column_1 LIKE &#39;B%&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;[张李王]三&#39;;  &#x2F;&#x2F;表示column_1中有匹配张三、李三、王三的都可以</span><br><span class="line">SELECT * FROM table_name WHERE column_1 LIKE &#39;[^张李王]三&#39;;  &#x2F;&#x2F;表示column_1中有匹配除了张三、李三、王三的其他三都可以</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示其中的某一个字符；[^]表示除了其中的字符的所有字符</span><br><span class="line"></span><br><span class="line">或者在全文索引中模糊查询</span><br><span class="line">SELECT * FROM table_name WHERE MATCH(content) AGAINST(&#39;word1&#39;,&#39;word2&#39;,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX my_index ON tablename；</span><br><span class="line">或者</span><br><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
<p>查看表中的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM tablename</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>索引分类</strong></p>
<p><strong>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</strong></p>
<ul>
<li><p>主键索引：非空唯一，只要建立主键就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alter table &#39;test&#39; add primary key pk_index(&#39;col&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>唯一索引：唯一，可以有多列，可以为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通索引：可不唯一，可为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>全文索引：对于大面积字符串统计出现单词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合索引：多列组合为一个索引，列中不许出现空值。遵循最左前缀原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>索引原理</strong></p>
<p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如<strong>BTree索引，B+Tree索引，哈希索引，全文索引</strong>等等**。</p>
<p><strong>1、哈希索引：</strong></p>
<p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p>
<p><strong>2、全文索引：</strong></p>
<p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，因为没使用索引。这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加。</p>
<p><strong>3、BTree索引和B+Tree索引</strong></p>
<h4 id="画重点了啊！"><a href="#画重点了啊！" class="headerlink" title="画重点了啊！"></a>画重点了啊！</h4><p>首先还是从二叉树谈起吧。B+树索引是B+树在<a href="http://lib.csdn.net/base/mysql">数据库</a>中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkCNdO.png" alt="dkCNdO.png"></p>
<p>这就是一个二插搜索数，左子树的键值小于根的键值，右子树的键值大于根的键值。 但是，如果增删过一段时间后，可能就变成了下图。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkC0Wd.png" alt="dkC0Wd.png"></p>
<p>这样效率就与链表无异了，所以在这基础上又有了平衡二叉树（AVL Tree), 而里面又诞生了红黑树。主要就是确保增删查改的复杂度都能维持在logn。这样在数据很多的情况下，二叉树遇到了信息量不足的瓶颈，因为再怎么样，一个node也只能知道他的左右节点。但是这已经是二叉树的极限了，聪明的人就想出，既然二叉能保存的信息有限，那我就用多叉树好了。也就是所谓的多路查找平衡树，B-Tree。</p>
<p>同时我们要改变另一个概念，好多人问他为什么用索引，他就说能快速找到数据，你问他为啥，他也会告诉你，因为用b树，b+树搜索变快了，从n变成了logn。但仔细想一想红黑数也可以啊，为什么一定是多路搜索树呢？那就要从另一个角度去看问题。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在<a href="http://lib.csdn.net/base/mysql">MySQL</a>中可通过如下命令查看页的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;innodb_page_size&#39;;</span><br></pre></td></tr></table></figure>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会<strong>减少磁盘I/O次数</strong>，提高查询效率。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkApCD.png" alt="dkApCD.png"></p>
<p><strong>B+Tree</strong></p>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkFQJg.png" alt="dkFQJg.png"></p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 <em> 10^3 </em> 10^3 = 10亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。<a href="http://lib.csdn.net/base/mysql">mysql</a>的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
<p><strong>B+Tree对比BTree的优点：</strong></p>
<ul>
<li>磁盘读写代价更低</li>
</ul>
<p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p>
<ul>
<li>查询速度更稳定</li>
</ul>
<p>由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的。</p>
</li>
<li><p><strong>聚簇索引和非聚簇索引</strong></p>
<h4 id="第二个重点啊"><a href="#第二个重点啊" class="headerlink" title="第二个重点啊"></a>第二个重点啊</h4><p>分析了MySQL的索引结构的实现原理，然后我们来看看具体的存储引擎怎么实现索引结构的，MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p>
<p>聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序</p>
<p>非聚簇索引的解释是:索引顺序与数据物理排列顺序无关</p>
<p><strong>MyISAM——非聚簇索引</strong></p>
<ul>
<li>MyISAM存储引擎采用的是非聚簇索引，非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。</li>
<li>非聚簇索引的数据表和索引表是分开存储的。</li>
<li>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</li>
</ul>
<p><strong>InnoDB——聚簇索引</strong></p>
<ul>
<li>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。</li>
<li>聚簇索引的数据和主键索引存储在一起。</li>
<li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。</li>
<li>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</li>
</ul>
<p>使用主索引的时候，更适合使用聚簇索引，因为聚簇索引只需要查找一次，而非聚簇索引在查到数据的地址后，还要进行一次I/O查找数据。</p>
<p>因为聚簇辅助索引存储的是主键的键值，因此可以在数据行移动或者页分裂的时候降低成本，因为这时不用维护辅助索引。但是由于主索引存储的是数据本身，因此聚簇索引会占用更多的空间。</p>
<p>聚簇索引在插入新数据的时候比非聚簇索引慢很多，因为插入新数据时需要检测主键是否重复，这需要遍历主索引的所有叶节点，而非聚簇索引的叶节点保存的是数据地址，占用空间少，因此分布集中，查询的时候I/O更少，但聚簇索引的主索引中存储的是数据本身，数据占用空间大，分布范围更大，可能占用好多的扇区，因此需要更多次I/O才能遍历完毕。</p>
<p><a href="https://imgchr.com/i/dkZaRS"><img src="https://s1.ax1x.com/2020/08/15/dkZaRS.jpg" alt="dkZaRS.jpg"></a></p>
</li>
<li><p><strong>索引的使用测略</strong></p>
<h4 id="第三个重点"><a href="#第三个重点" class="headerlink" title="第三个重点"></a>第三个重点</h4><p><strong>什么时候要使用索引？</strong></p>
<ul>
<li>主键自动建立唯一索引；</li>
<li>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；</li>
<li>作为排序的列要建立索引；</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>高并发条件下倾向组合索引；</li>
<li>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</li>
</ul>
<p><strong>什么时候不要使用索引？</strong></p>
<ul>
<li>经常增删改的列不要建立索引；</li>
<li>有大量重复的列不建立索引；</li>
<li>表记录太少不要建立索引。只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快—不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。</li>
</ul>
<p><strong>索引失效的情况：</strong></p>
<ul>
<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>
<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>
<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>
<li>在索引的列上使用表达式或者函数会使索引失效，例如：select <em> from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select </em> from users where adddate&lt;’2007-01-01′。其它通配符同样，也就是说，在查询条件中使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。</li>
<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（经erwkjrfhjwkdb同学提醒，不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>
<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>
<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败，应该改为WHERE email=’99999’。</li>
<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。</li>
<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>
<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引；</li>
</ul>
</li>
</ol>
<p>   Tips：</p>
<p>   1、最左前缀</p>
<p>   索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引<col1,col2,col3>那么以下3中情况可以使用索引：col1，<col1,col2>，<col1,col2,col3>，其它的列，比如<col2,col3>，<col1,col3>，col2，col3等等都是不能使用索引的。</p>
<p>   根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。</p>
<p>   2、带索引的模糊查询优化</p>
<p>   在上面已经提到，使用LIKE进行模糊查询的时候，’%aaa%’不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化（上文有讲到）。</p>
<p>   3、为检索的条件构建全文索引，然后使用</p>
<blockquote>
<p>SELECT * FROM tablename MATCH(index_colum) ANGAINST(‘word’);</p>
</blockquote>
<p>   4、使用短索引</p>
<p>   对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p>
<p>相关文章:</p>
<p><a href="https://www.jianshu.com/p/c82148473235">无语，我差点被面试官怼坏了，又给我问到MySQL索引</a></p>
<p><a href="https://www.cnblogs.com/vianzhang/p/7922426.html">BTree和B+Tree详解</a>         </p>
]]></content>
      <categories>
        <category>整理总结</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
