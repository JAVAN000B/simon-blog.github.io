<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/simon-blog.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/simon-blog.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/simon-blog.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/simon-blog.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/simon-blog.github.io/css/main.css">


<link rel="stylesheet" href="/simon-blog.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"javan000b.github.io","root":"/simon-blog.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试3板斧， 数据库，操作系统，计算机网络。 什么你说语言？这个，不同岗位面不同语言吗，但上面这三个是跑不掉的。索性计算机网络需要掌握的没有数据库来的多。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络知识整理">
<meta property="og:url" content="https://javan000b.github.io/simon-blog.github.io/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="At least, keep busy">
<meta property="og:description" content="面试3板斧， 数据库，操作系统，计算机网络。 什么你说语言？这个，不同岗位面不同语言吗，但上面这三个是跑不掉的。索性计算机网络需要掌握的没有数据库来的多。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkaRfS.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dk4gzj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkIpBq.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkImuR.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkI058.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkIs2Q.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkTgA0.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkTvge.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dk7hIP.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkHkZR.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkbR4P.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkOKht.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dkOY7j.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/15/dAFGuR.jpg">
<meta property="article:published_time" content="2020-08-15T09:45:28.000Z">
<meta property="article:modified_time" content="2020-08-15T14:33:53.927Z">
<meta property="article:author" content="Simon Sun">
<meta property="article:tag" content="知识整理">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/08/15/dkaRfS.jpg">

<link rel="canonical" href="https://javan000b.github.io/simon-blog.github.io/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>计算机网络知识整理 | At least, keep busy</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/simon-blog.github.io/atom.xml" title="At least, keep busy" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/simon-blog.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">At least, keep busy</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/simon-blog.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/simon-blog.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/simon-blog.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/simon-blog.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/simon-blog.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://javan000b.github.io/simon-blog.github.io/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/simon-blog.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Simon Sun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="At least, keep busy">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络知识整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-15 17:45:28 / Modified: 22:33:53" itemprop="dateCreated datePublished" datetime="2020-08-15T17:45:28+08:00">2020-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/simon-blog.github.io/categories/%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">整理总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试3板斧， 数据库，操作系统，计算机网络。 什么你说语言？这个，不同岗位面不同语言吗，但上面这三个是跑不掉的。索性计算机网络需要掌握的没有数据库来的多。</p>
<a id="more"></a>
<ol>
<li><p>网络结构</p>
<p>OSI 7层：拆分应用层，额外分出表示层，会话层</p>
<p>TCP/IP 4层：应用层，传输层，网际层，网络以下一层</p>
<p>5层结构：物理层，链路层</p>
<ul>
<li><strong>1. 应用层</strong></li>
</ul>
<p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<ul>
<li><strong>2. 运输层</strong></li>
</ul>
<p>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<ul>
<li><strong>3. 网络层</strong></li>
</ul>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<ul>
<li><strong>4. 数据链路层</strong></li>
</ul>
<p>数据链路层（data link  layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<ul>
<li><strong>5. 物理层</strong></li>
</ul>
<p>在物理层上所传送的数据单位是比特。物理层（physical  layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkaRfS.jpg" alt="dkaRfS.jpg"></p>
</li>
</ol>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ol>
<li><p>APR协议工作原理</p>
<p>IP地址到mac地址。</p>
<p>​    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。                                   </p>
<p>​     2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：<strong>源主机IP地址，源主机MAC地址，目的主机的IP地址</strong>。                                   </p>
<p>​      3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。                                                                                                                        </p>
<p>​      4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dk4gzj.png" alt="dk4gzj.png">                                                               </p>
</li>
<li><p>IP协议</p>
<p><strong>互联网协议地址</strong>（英语：Internet Protocol Address，又译为<strong>网际协议地址</strong>），缩写为<strong>IP地址</strong>（英语：IP Address），是分配给用户上网使用的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>（英语：Internet Protocol, IP）的设备的数字标签。常见的IP地址分为<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/IPv4">IPv4</a>与<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/IPv6">IPv6</a>两大类，但是也有其他不常用的小分类。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkIpBq.jpg" alt="dkIpBq.jpg"></p>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li>
</ul>
</li>
<li><p>IP地址分类</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkImuR.jpg" alt="dkImuR.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkI058.jpg" alt="dkI058.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkIs2Q.jpg" alt="dkIs2Q.jpg"></p>
</li>
</ol>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP（Transmission Control Protocol <a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/9727741">传输控制协议</a>）是一种面向连接的、可靠的、基于字节流的<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536">传输层</a>通信协议，由IETF的RFC 793定义。</p>
<ol>
<li><p>主要特点</p>
<p>\1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
<p>\2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</p>
<p>\3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
<p>\4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
<p>\5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</li>
<li><p>TCP如何保证传输可靠</p>
<ul>
<li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p>
</li>
<li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p>
</li>
<li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</p>
</li>
<li><p><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
</li>
<li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</li>
<li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<ul>
<li><p>具体的，滑动窗口：<strong>接收窗口只会对窗口内最后一个按序到达的字节进行确认</strong></p>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31  进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkTgA0.jpg" alt="dkTgA0.jpg"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>壅塞控制</p>
<p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。<strong>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkTvge.jpg" alt="dkTvge.jpg"></p>
<p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：  A、慢启动  B、拥塞避免  C、快重传  D、快恢复</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。<strong>具体发送数量，哪个小用哪个。</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/15/dk7hIP.jpg" alt="dk7hIP.jpg"></p>
</li>
<li><p>三次握手</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkHkZR.jpg" alt="dkHkZR.jpg"></p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p>
<p>一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。</p>
<p><strong>第一次握手</strong>：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位  SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1  的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p><strong>第二次握手</strong>：B  收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x +  1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入  SYN-RCVD（同步收到）状态。</p>
<p><strong>第三次握手</strong>：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置  1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK  报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<ul>
<li><p>为什么不能两次握手</p>
<p>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A  发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达  B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A  发出确认报文段，同意建立连接。</p>
<p>对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。</p>
<p>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<p>本来收到消息后就该发ACK，这是快速回复机制。而且三次握手都没挡住ddos攻击，何况两次</p>
</li>
<li><p>为什么不需要4次？</p>
<p>在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</p>
<p>同理，你可以反问对方为什么不需要5次。</p>
</li>
<li><p>Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN</p>
<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
</li>
<li><p>传了SYN为什么还需要ACK</p>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
</li>
</ul>
</li>
<li><p>四次挥手</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkbR4P.jpg" alt="dkbR4P.jpg"></p>
<p><strong>第一次挥手</strong>：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位  FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入  FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p>
<p><strong>第二次挥手</strong>：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B  前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP  服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A  收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p>
<p><strong>第三次挥手</strong>：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入  LAST-ACK(最后确认)状态，等待 A 的确认。</p>
<p><strong>第四次挥手</strong>：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号  seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP  连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED  状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED  状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
<ul>
<li><p>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢</p>
<ol>
<li><p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B  收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 +  1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到  CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
</li>
<li><p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
</li>
<li><p>为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么</p>
<p>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</p>
</li>
<li><p><strong>保活计时器的作用</strong></p>
<p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP  连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
</li>
</ul>
</li>
<li><p>TCP粘包</p>
<ol>
<li><p>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
</li>
<li><p>从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p>
</li>
</ol>
<p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<ul>
<li><strong>发送方产生粘包</strong></li>
</ul>
<p>采用 TCP  协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle  算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<ul>
<li><strong>接收方产生粘包</strong></li>
</ul>
<p>接收方采用 TCP  协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP  协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read  等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<ul>
<li><p>怎么解决</p>
<ol>
<li><p>特殊字符控制；</p>
</li>
<li><p>在包头首都添加数据包的长度。</p>
</li>
<li>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ol>
<li><p>TCP和UDP的区别</p>
<ol>
<li>TCP面向连接，传输数据之前要需要建立会话。UDP是无连接的。</li>
<li>TCP提供可靠传输，保证数据不丢包、不重复且按顺序到达；UDP只尽努力交付，不保证可靠交付</li>
<li>TCP提供了拥塞控制；UDP不提供</li>
<li>TCP是面向字节流的；UDP面向报文。</li>
<li>TCP只支持点到点通信；UDP支持一对一、一对多、多对多的交互通信。</li>
<li>TCP首部开销大20字节，UDP首部开销小8字节。</li>
</ol>
</li>
<li><p>UDP首部格式</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkOKht.jpg" alt="dkOKht.jpg"></p>
<p>反观TCP的报文头：没有长度！</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dkOY7j.jpg" alt="dkOY7j.jpg"></p>
</li>
<li><p>对应应用</p>
<p><strong>1). TCP对应的应用层协议</strong></p>
<ul>
<li>FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
<li>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</li>
<li>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</li>
<li>POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</li>
<li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<p><strong>2). UDP对应的应用层协议</strong></p>
<ul>
<li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li>
<li>SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</li>
</ul>
</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote>
<p><strong>超文本传输协议</strong>（<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD">英语</a>：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%B8%AE%E5%AF%AB">缩写</a>：<strong>HTTP</strong>）是一种用于分布式、协作式和<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>信息系统的<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层协议</a><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%23cite_note-ietf2616-1">[1]</a>。HTTP是<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>的数据通信的基础。</p>
</blockquote>
<p>HTTP协议定义了浏览器（即互联网客户进程）怎样向万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP是面向事务的应用层协议，它是万维网能够可靠的交付文件的重要基础。</p>
<ul>
<li>HTTP构建于TCP/IP协议之上，默认端口号是80</li>
<li>HTTP是<strong>无连接无状态</strong>的</li>
</ul>
<ol>
<li><p>状态码</p>
<ul>
<li><strong>1XX 信息</strong></li>
</ul>
<ol>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。HTTP1.1</li>
</ol>
<ul>
<li><strong>2XX 成功</strong></li>
</ul>
<ol>
<li><p>200 OK</p>
</li>
<li><p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ol>
<ul>
<li><strong>3XX 重定向</strong></li>
</ul>
<ol>
<li><p>301 Moved Permanently ：永久性重定向；</p>
</li>
<li><p>302 Found ：临时性重定向；</p>
</li>
<li><p>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li><p>304 Not Modified  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li><p>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ol>
<ul>
<li><strong>4XX 客户端错误</strong></li>
</ul>
<ol>
<li><p>400 Bad Request ：请求报文中存在语法错误。</p>
</li>
<li><p>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p>403 Forbidden ：请求被拒绝。</p>
</li>
<li><p>404 Not Found</p>
</li>
</ol>
<ul>
<li><strong>5XX 服务器错误</strong></li>
</ul>
<ol>
<li><p>500 Internal Server Error ：服务器正在执行请求时发生错误；</p>
</li>
<li><p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ol>
</li>
<li><p>forward 和 redirect 的区别？</p>
<p>Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。</p>
<p>直接转发方式（Forward）：<strong>客户端和浏览器只发出一次请求</strong>，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</p>
<p>间接转发方式（Redirect）：<strong>实际是两次 HTTP 请求</strong>，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</p>
</li>
<li><p>RESTFUL方法</p>
<ol>
<li><p>GET：获取资源，当前网络中绝大部分使用的都是 GET；</p>
</li>
<li><p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>DELETE：删除资源</p>
</li>
</ol>
</li>
<li><p>GET 和 POST 的区别</p>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<p>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p>
<ol>
<li><p>从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</p>
</li>
<li><p>从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</p>
</li>
<li><p>从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL  和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为  application/x-www-form-urlencoded MIME  字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中  ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</p>
</li>
<li><p>就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</p>
</li>
<li><p>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p>
</li>
</ol>
</li>
<li><p>POST和PUT</p>
<p>有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p>
<p>在HTTP中，PUT被定义为idempotent的方法，POST则不是，这是一个很重要的区别。 </p>
</li>
<li><p>在浏览器中输入 URL 地址到显示主页的过程</p>
<ol>
<li><p>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS  缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS  服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地  DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP  地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
</li>
<li><p>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</p>
</li>
<li><p>发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</p>
</li>
<li><p>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
</li>
<li><p>浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
<li><p>连接结束。</p>
</li>
</ol>
</li>
<li><p>整个网络请求的优化，尤其是对http</p>
<ul>
<li>DNS预解析，由浏览器提供，通过预加载一些域名，提前去做DNS解析，加快响应速度。</li>
<li>域名收敛，由服务器统一汇总不同的域名，由再对访问进行转发。</li>
<li>资源内联，由于每个资源首次访问都存在握手等RTT损耗，越少数量的资源请求，可以节约获取资源的时间，例如一个html中src访问一个css，就不如，将这个css直接以style集成在html当中，会减少访问。（webpack等一些构建工具，也可以将html与css当到一个文件当中。）</li>
<li>SSR，并非抽卡，而是服务器加载，传统的方式显示一个页面会发送多次请求，第一次拿到html资源，然后通过请求，再去拿数据，再将数据渲染到页面上。这样的多次请求，会增加页面的响应时间，如果在服务器端，就将页面渲染好，再发送至客户端，也可以间接减少RTT。即（react等框架的SSR）</li>
<li>图片懒加载，没看到的地方先不管</li>
<li>HTTP2,下面有说</li>
</ul>
</li>
<li><p>DNS</p>
<p>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。</p>
<p><img src="https://s1.ax1x.com/2020/08/15/dAFGuR.jpg" alt="dAFGuR.jpg"></p>
<ol>
<li><p>HTTP 1.0,1.1,2.0</p>
<ul>
<li><strong>HTTP1.1 的主要变化：</strong></li>
</ul>
<ol>
<li><p>HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。</p>
</li>
<li><p>然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。</p>
</li>
<li><p>HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。</p>
</li>
</ol>
<ul>
<li><strong>HTTP2.0 的主要变化：</strong></li>
</ul>
<ol>
<li><p>HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；</p>
</li>
<li><p>HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；</p>
</li>
<li><p>HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；</p>
</li>
<li><p>HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/j_bleach/article/details/75215499">http请求过程及性能优化分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1093515208294834176">计算机网络基础知识</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84316213">计算机网络太难？了解这一篇就够了</a></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/simon-blog.github.io/tags/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" rel="tag"># 知识整理</a>
              <a href="/simon-blog.github.io/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/simon-blog.github.io/2020/08/14/MySQL%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/" rel="prev" title="MySQL索引知识">
      <i class="fa fa-chevron-left"></i> MySQL索引知识
    </a></div>
      <div class="post-nav-item">
    <a href="/simon-blog.github.io/2020/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="next" title="机器学习笔记（二）">
      机器学习笔记（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">2.1.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">2.2.</span> <span class="nav-text">UDP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">3.1.</span> <span class="nav-text">HTTP</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Simon Sun"
      src="/simon-blog.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Simon Sun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/simon-blog.github.io/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/simon-blog.github.io/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/simon-blog.github.io/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/JAVAN000B" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JAVAN000B" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:smh335789877@gmail.com" title="E-Mail → mailto:smh335789877@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Simon Sun</span>
</div>

    <div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv" style='display:none'>
        本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
        <span class="post-meta-divider">|</span>
    </span>
    <span id="busuanzi_container_site_uv" style='display:none'>
        有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
    </span>
    </div>


  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/simon-blog.github.io/lib/anime.min.js"></script>
  <script src="/simon-blog.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/simon-blog.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/simon-blog.github.io/js/utils.js"></script>

<script src="/simon-blog.github.io/js/motion.js"></script>


<script src="/simon-blog.github.io/js/schemes/pisces.js"></script>


<script src="/simon-blog.github.io/js/next-boot.js"></script>




  




  
<script src="/simon-blog.github.io/js/local-search.js"></script>













  

  

  

</body>
</html>
